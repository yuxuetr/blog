[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/poetry_pyright_doom_emacs/index.html",
    "href": "posts/poetry_pyright_doom_emacs/index.html",
    "title": "Doom Emacs & Poetry & Pyright管理Python开发环境",
    "section": "",
    "text": "Doom Emacs的python配置\n\n(python\n  +poetry\n  +pyright)\n\nInstall Poetry\n\npip install poetry\n\nInstall Pyright\n\nnpm install -g pyright\n\n\n\nmkdir project_name && cd project_name\npoetry init\npoetry install\npoetry add flask\nEmacs打开project_name/app.py\n这样Doom Emacs配置的Poetry的虚拟环境中的Flask,可以在python的LSP补全后端补全flask的代码了\n\n\n\n刚配置完成后，创建Poetry项目后可以正常激活，但是Pyright始终无法补全 最终在Reddit Link 中有人编辑器用了Github Repo上的一个项目后，然后 打开别的Poetry创建的项目，有人讨论说，可能是因为上面的Github仓库中多了poetry.toml文件 内容如下:\n[virtualenvs]\nin-project = true"
  },
  {
    "objectID": "posts/poetry_pyright_doom_emacs/index.html#记录doom-emacs-使用poetry管理的多虚拟环境使用pyright补全",
    "href": "posts/poetry_pyright_doom_emacs/index.html#记录doom-emacs-使用poetry管理的多虚拟环境使用pyright补全",
    "title": "Doom Emacs & Poetry & Pyright管理Python开发环境",
    "section": "",
    "text": "Doom Emacs的python配置\n\n(python\n  +poetry\n  +pyright)\n\nInstall Poetry\n\npip install poetry\n\nInstall Pyright\n\nnpm install -g pyright\n\n\n\nmkdir project_name && cd project_name\npoetry init\npoetry install\npoetry add flask\nEmacs打开project_name/app.py\n这样Doom Emacs配置的Poetry的虚拟环境中的Flask,可以在python的LSP补全后端补全flask的代码了\n\n\n\n刚配置完成后，创建Poetry项目后可以正常激活，但是Pyright始终无法补全 最终在Reddit Link 中有人编辑器用了Github Repo上的一个项目后，然后 打开别的Poetry创建的项目，有人讨论说，可能是因为上面的Github仓库中多了poetry.toml文件 内容如下:\n[virtualenvs]\nin-project = true"
  },
  {
    "objectID": "posts/rust-prelude/index.html",
    "href": "posts/rust-prelude/index.html",
    "title": "Rust Prelude",
    "section": "",
    "text": "Rust Prelude是Rust标准库隐式导入到每个Rust程序中。\n它就像呼吸一样无需调用就存在，也可以明确调用。\n它包含许多常用类型、函数和宏。\n为编写Rust程序提供了大量功能。但不是所有情况下都是最佳选择。"
  },
  {
    "objectID": "posts/rust-prelude/index.html#什么是rust-prelude",
    "href": "posts/rust-prelude/index.html#什么是rust-prelude",
    "title": "Rust Prelude",
    "section": "",
    "text": "Rust Prelude是Rust标准库隐式导入到每个Rust程序中。\n它就像呼吸一样无需调用就存在，也可以明确调用。\n它包含许多常用类型、函数和宏。\n为编写Rust程序提供了大量功能。但不是所有情况下都是最佳选择。"
  },
  {
    "objectID": "posts/rust-prelude/index.html#什么时候使用rust-prelude",
    "href": "posts/rust-prelude/index.html#什么时候使用rust-prelude",
    "title": "Rust Prelude",
    "section": "什么时候使用Rust Prelude",
    "text": "什么时候使用Rust Prelude\nRust Prelude时一款出色的默认设置，可满足大多数基本需求，在以下情况下应使用\n\n需要常见的数据结构例如：Strings, Vectors, HashMaps\n需要常用的迭代函数，如：map, filter, any, all等\n需要常见的转换函数，如：from_str 和 to_string\n需要使用常见宏，如：println!, panic!, unreachable!等\n程序比较短小精悍，需要大量功能而不需要很多导入"
  },
  {
    "objectID": "posts/rust-prelude/index.html#什么时候不使用rust-prelude",
    "href": "posts/rust-prelude/index.html#什么时候不使用rust-prelude",
    "title": "Rust Prelude",
    "section": "什么时候不使用Rust Prelude",
    "text": "什么时候不使用Rust Prelude\n\n名称冲突：Prelude到处了许多常用名称，因此导入具有相同名称的另一个crates可能会导致冲突\n更专业的功能：对于更多特定领域的用例，最好使用专门的crates\n为了提高性能：一些Prelude是通用的，对于高性能需求，专门的crates可能更好"
  },
  {
    "objectID": "posts/rust_sdl2/index.html",
    "href": "posts/rust_sdl2/index.html",
    "title": "Rust SDL2案例",
    "section": "",
    "text": "案例来自于Rust Programming by Example,由于按照书籍的操作会存在一些错误，所以用此博客来记录更多的细节。\n\n\n\nMacOS M2: 13.5.2\nRust: 1.70.0\n\n\n\n\n\n创建工程\n\ncargo new tetris\n\n添加依赖于Cargo.toml\n\n[package]\nname = \"tetris\"\nversion = \"0.0.1\"\n\n[dependencies]\nsdl2 = \"0.34.5\"\n\n安装SDL2\n\nbrew install sdl2\n\n配置环境变量\n\nexport RUSTFLAGS=\"-L /opt/homebrew/lib\"\n此处RUSTFLAGS环境变量的内容需要根据自己的SDL2库的安装路径来配置，由于我的库安装路径是/opt/homebrew/lib下。 执行cargo build编译程序会依赖SDL的动态库；同时我也尝试了其他两种方法并没有成功\n其它方法一： 设置环境变量DYLD_LIBRARY_PATH\nexport DYLD_LIBRARY_PATH=/opt/homebrew/lib\n其它方法二： 在Cargo.toml中添加\n[build]\nrustc-link-search = [\"/opt/homebrew/lib\"]\n\n基础示例代码\n\nextern crate sdl2;\n\nuse sdl2::event::Event;\nuse sdl2::keyboard::Keycode;\nuse sdl2::pixels::Color;\nuse std::time::Duration;\n\nfn main() {\n    // 初始化SDL2\n    let sdl_context = sdl2::init().unwrap();\n    let video_subsystem = sdl_context.video().unwrap();\n\n    // 创建窗口和画布\n    let window = video_subsystem\n        .window(\"SDL2 Window\", 800, 600)\n        .position_centered()\n        .build()\n        .unwrap();\n\n    let mut canvas = window.into_canvas().build().expect(\"Failed to convert window into canvas\");\n\n    // 渲染代码\n    canvas.set_draw_color(Color::RGB(255, 0, 0));\n    canvas.clear();\n    canvas.present();\n\n    // 创建事件处理器\n    let mut event_pump = sdl_context.event_pump().expect(\"Failed to get SDL event pump\");\n\n    // 主循环\n    'runningloop: loop {\n        for event in event_pump.poll_iter() {\n            match event {\n                Event::Quit { .. } | Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {\n                    break 'runningloop;\n                }\n                _ =&gt; {}\n            }\n        }\n\n        // 添加延迟以控制帧率\n        std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));\n    }\n}\n\n构建程序\n\ncargo build\n\n运行程序\n\ncargo run\n运行结果如下图： \n\n实现过程\n\n\n导入外部crate SDL2\nextern crate sdl2;\n初始化SDL context\nlet sdl_context = sdl2::init().expect(\"SDL initialization failed\");\n获取video subsystem\nlet video_subsystem = sdl_context.video().expect(\"Couldn't get SDL\n       video subsystem\");\n创建windows\nlet window = video_subsystem.window(\"Tetris\", 800, 600)\n                             .position_centered()\n                             .opengl()\n                             .build()\n                             .expect(\"Failed to create window\");\n\nthe parameters for the window method\n\ntitle\nwidth\nheight\n\n.position_centered() method\n\n在屏幕中间获取窗口\n\n.opengl()\n\n让SDL使用opengl渲染\n\n.build()\n\n根据前面提供的参数创建窗口\n\n.expect()\n\n处理异常\n\n\n事件循环 正常情况下，展示一个窗口并关闭特别快，我们需要添加时间循环确保窗口一直在运行。\n\n导入必要相关的库\n\nuse sdl2::event::Event;\nuse sdl2::keyboard::Keycode;\n\nuse std::thread::sleep;\nuse std::time::Duration;\n\n获取时间循环管理器\n\nlet mut event_pump = sdl_context.event_pump().expect(\"Failed to\n        get SDL event pump\");\n\n创建无限循环循环事件\n\n'running: loop {\n     for event in event_pump.poll_iter() {\n         match event {\n             Event::Quit { .. } |\n             Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {\n                 break 'running // We \"break\" the infinite loop.\n             },\n             _ =&gt; {} \n         }\n     }\n     sleep(Duration::new(0, 1_000_000_000u32 / 60));\n}\nrunning是一个循环跳出的标签(label) 收到一个quit event或者按Esc键，程序退出\n\n\n\n\n\n当我们有了一个窗口(window)时，我们需要获取(get)窗口的画布(window’s canvas)\n\nlet mut canvas = window.into_canvas()\n                 .target_texture()\n                 .present_vsync()\n                 .build()\n                 .expect(\"Couldn't get window's canvas\");\n以上代码的简单说明：\n\ninto_canvas: 将窗口(window)转换为画布(canvas)，以便我们可以轻松操作它\ntarget_texture: 激活纹理渲染支持\npresent_vsync: 允许v-sync(竖直同步操作)限制\nbuild: 应用前面设置的参数创建画布(canvas)\n\n\n\n\n当我们有了一个窗口的画布时，我们可以创建纹理，粘贴(paste onto)在其上。 获取(get)一个纹理创造器(texture creator)\n\n添加包含的结构\nuse sdl2::render::{Canvas, Texture, TextureCreator};\n获取纹理创造器\nlet texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();\n\n\n\n\n首先创建一个常量确定矩形的尺寸，然后使用纹理创造器创建一个矩形的纹理\n\n设置矩形矩形的尺寸\nconst TEXTURE_SIZE: u32 = 32; // 矩形的尺寸大小 \n使用纹理创造器创建矩形\nconst TEXTURE_SIZE: u32 = 32; // 矩形的尺寸大小\nlet mut square_texture: Texture =\n   texture_creator.create_texture_target(None, TEXTURE_SIZE,\n     TEXTURE_SIZE)\n   .expect(\"Failed to create a texture\");\n\n\n\n\n要为纹理设置颜色，需要引入颜色模块的结构，然后使用画布设置纹理的颜色，颜色绘制完成后需要清空纹理；\n\n引入颜色结构\nuse sdl2::pixels::Color;\n使用画布设置矩形纹理的颜色\ncanvas.with_texture_canvas(&mut square_texture, |texture| {\n  texture.set_draw_color(Color::RGB(0, 255, 0));\n  texture.clear();\n})\n\n代码的简单说明:\n为了更新窗口的渲染内容，我们需要在将代码包含在main loop(and after the event loop). clear()纹理，以至于它被填充绿色\n\n将窗口填充红色\ncanvas.set_draw_color(Color::RGB(255, 0, 0));\ncanvas.clear();\n将纹理拷贝到窗口中\ncanvas.copy(&square_texture, None, Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))\n      .expect(\"Couldn't copy texture into window\");\n最后更新窗口的展示\ncanvas.present();\n\n代码如下：\nextern crate sdl2;\n\nuse sdl2::event::Event;\nuse sdl2::keyboard::Keycode;\nuse sdl2::pixels::Color;\nuse sdl2::render::{Texture, TextureCreator};\nuse sdl2::rect::Rect;\nuse std::time::Duration;\n\nfn main() {\n     // 初始化SDL2\n     let sdl_context = sdl2::init().expect(\"SDL initialization failed\");\n     let video_subsystem = sdl_context.video().expect(\"Couldn't get SDL video subsystem\");\n\n     // 创建窗口和画布\n     let window = video_subsystem\n         .window(\"Tetris\", 800, 600)\n         .position_centered()\n         .build()\n         .expect(\"Failed to create window\");\n\n     let mut canvas = window.into_canvas()\n         .target_texture()\n         .present_vsync()\n         .build()\n         .expect(\"Couldn't get window's canvas\");\n\n     let texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();\n     const TEXTURE_SIZE: u32 = 32;\n\n     // create a texture with a 32*32 size\n     let mut square_texture: Texture = texture_creator.create_texture_target(None, TEXTURE_SIZE, TEXTURE_SIZE)\n         .expect(\"Failed to create a texture\");\n\n     // use the canvas to draw into our square texture.\n     canvas.with_texture_canvas(&mut square_texture, |texture| {\n         // set the draw color to green\n         texture.set_draw_color(Color::RGB(0, 255, 0));\n         texture.clear();\n     }).expect(\"Failed to clear a texture\");\n\n     // 创建事件处理器\n     let mut event_pump = sdl_context.event_pump().expect(\"Failed to get SDL event pump\");\n\n     // 主循环\n     'runningloop: loop {\n         for event in event_pump.poll_iter() {\n             match event {\n                 Event::Quit { .. } | Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {\n                     break 'runningloop;\n                 }\n                 _ =&gt; {}\n             }\n         }\n\n         // We set fulfill our window with red\n         canvas.set_draw_color(Color::RGB(255, 0, 0));\n         // We draw it\n         canvas.clear();\n         // Copy our texture into the window\n         canvas.copy(&square_texture, None, Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))\n             .expect(\"Couldn't copy texture into window\");\n         canvas.present();\n\n         // 添加延迟以控制帧率\n         std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));\n     }\n}\n\n代码执行结果如下图所示:"
  },
  {
    "objectID": "posts/rust_sdl2/index.html#实验环境",
    "href": "posts/rust_sdl2/index.html#实验环境",
    "title": "Rust SDL2案例",
    "section": "",
    "text": "MacOS M2: 13.5.2\nRust: 1.70.0"
  },
  {
    "objectID": "posts/rust_sdl2/index.html#初始化开发环境",
    "href": "posts/rust_sdl2/index.html#初始化开发环境",
    "title": "Rust SDL2案例",
    "section": "",
    "text": "创建工程\n\ncargo new tetris\n\n添加依赖于Cargo.toml\n\n[package]\nname = \"tetris\"\nversion = \"0.0.1\"\n\n[dependencies]\nsdl2 = \"0.34.5\"\n\n安装SDL2\n\nbrew install sdl2\n\n配置环境变量\n\nexport RUSTFLAGS=\"-L /opt/homebrew/lib\"\n此处RUSTFLAGS环境变量的内容需要根据自己的SDL2库的安装路径来配置，由于我的库安装路径是/opt/homebrew/lib下。 执行cargo build编译程序会依赖SDL的动态库；同时我也尝试了其他两种方法并没有成功\n其它方法一： 设置环境变量DYLD_LIBRARY_PATH\nexport DYLD_LIBRARY_PATH=/opt/homebrew/lib\n其它方法二： 在Cargo.toml中添加\n[build]\nrustc-link-search = [\"/opt/homebrew/lib\"]\n\n基础示例代码\n\nextern crate sdl2;\n\nuse sdl2::event::Event;\nuse sdl2::keyboard::Keycode;\nuse sdl2::pixels::Color;\nuse std::time::Duration;\n\nfn main() {\n    // 初始化SDL2\n    let sdl_context = sdl2::init().unwrap();\n    let video_subsystem = sdl_context.video().unwrap();\n\n    // 创建窗口和画布\n    let window = video_subsystem\n        .window(\"SDL2 Window\", 800, 600)\n        .position_centered()\n        .build()\n        .unwrap();\n\n    let mut canvas = window.into_canvas().build().expect(\"Failed to convert window into canvas\");\n\n    // 渲染代码\n    canvas.set_draw_color(Color::RGB(255, 0, 0));\n    canvas.clear();\n    canvas.present();\n\n    // 创建事件处理器\n    let mut event_pump = sdl_context.event_pump().expect(\"Failed to get SDL event pump\");\n\n    // 主循环\n    'runningloop: loop {\n        for event in event_pump.poll_iter() {\n            match event {\n                Event::Quit { .. } | Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {\n                    break 'runningloop;\n                }\n                _ =&gt; {}\n            }\n        }\n\n        // 添加延迟以控制帧率\n        std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));\n    }\n}\n\n构建程序\n\ncargo build\n\n运行程序\n\ncargo run\n运行结果如下图： \n\n实现过程\n\n\n导入外部crate SDL2\nextern crate sdl2;\n初始化SDL context\nlet sdl_context = sdl2::init().expect(\"SDL initialization failed\");\n获取video subsystem\nlet video_subsystem = sdl_context.video().expect(\"Couldn't get SDL\n       video subsystem\");\n创建windows\nlet window = video_subsystem.window(\"Tetris\", 800, 600)\n                             .position_centered()\n                             .opengl()\n                             .build()\n                             .expect(\"Failed to create window\");\n\nthe parameters for the window method\n\ntitle\nwidth\nheight\n\n.position_centered() method\n\n在屏幕中间获取窗口\n\n.opengl()\n\n让SDL使用opengl渲染\n\n.build()\n\n根据前面提供的参数创建窗口\n\n.expect()\n\n处理异常\n\n\n事件循环 正常情况下，展示一个窗口并关闭特别快，我们需要添加时间循环确保窗口一直在运行。\n\n导入必要相关的库\n\nuse sdl2::event::Event;\nuse sdl2::keyboard::Keycode;\n\nuse std::thread::sleep;\nuse std::time::Duration;\n\n获取时间循环管理器\n\nlet mut event_pump = sdl_context.event_pump().expect(\"Failed to\n        get SDL event pump\");\n\n创建无限循环循环事件\n\n'running: loop {\n     for event in event_pump.poll_iter() {\n         match event {\n             Event::Quit { .. } |\n             Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {\n                 break 'running // We \"break\" the infinite loop.\n             },\n             _ =&gt; {} \n         }\n     }\n     sleep(Duration::new(0, 1_000_000_000u32 / 60));\n}\nrunning是一个循环跳出的标签(label) 收到一个quit event或者按Esc键，程序退出"
  },
  {
    "objectID": "posts/rust_sdl2/index.html#画布canvas",
    "href": "posts/rust_sdl2/index.html#画布canvas",
    "title": "Rust SDL2案例",
    "section": "",
    "text": "当我们有了一个窗口(window)时，我们需要获取(get)窗口的画布(window’s canvas)\n\nlet mut canvas = window.into_canvas()\n                 .target_texture()\n                 .present_vsync()\n                 .build()\n                 .expect(\"Couldn't get window's canvas\");\n以上代码的简单说明：\n\ninto_canvas: 将窗口(window)转换为画布(canvas)，以便我们可以轻松操作它\ntarget_texture: 激活纹理渲染支持\npresent_vsync: 允许v-sync(竖直同步操作)限制\nbuild: 应用前面设置的参数创建画布(canvas)"
  },
  {
    "objectID": "posts/rust_sdl2/index.html#纹理texture",
    "href": "posts/rust_sdl2/index.html#纹理texture",
    "title": "Rust SDL2案例",
    "section": "",
    "text": "当我们有了一个窗口的画布时，我们可以创建纹理，粘贴(paste onto)在其上。 获取(get)一个纹理创造器(texture creator)\n\n添加包含的结构\nuse sdl2::render::{Canvas, Texture, TextureCreator};\n获取纹理创造器\nlet texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();"
  },
  {
    "objectID": "posts/rust_sdl2/index.html#创建矩形",
    "href": "posts/rust_sdl2/index.html#创建矩形",
    "title": "Rust SDL2案例",
    "section": "",
    "text": "首先创建一个常量确定矩形的尺寸，然后使用纹理创造器创建一个矩形的纹理\n\n设置矩形矩形的尺寸\nconst TEXTURE_SIZE: u32 = 32; // 矩形的尺寸大小 \n使用纹理创造器创建矩形\nconst TEXTURE_SIZE: u32 = 32; // 矩形的尺寸大小\nlet mut square_texture: Texture =\n   texture_creator.create_texture_target(None, TEXTURE_SIZE,\n     TEXTURE_SIZE)\n   .expect(\"Failed to create a texture\");"
  },
  {
    "objectID": "posts/rust_sdl2/index.html#设置颜色",
    "href": "posts/rust_sdl2/index.html#设置颜色",
    "title": "Rust SDL2案例",
    "section": "",
    "text": "要为纹理设置颜色，需要引入颜色模块的结构，然后使用画布设置纹理的颜色，颜色绘制完成后需要清空纹理；\n\n引入颜色结构\nuse sdl2::pixels::Color;\n使用画布设置矩形纹理的颜色\ncanvas.with_texture_canvas(&mut square_texture, |texture| {\n  texture.set_draw_color(Color::RGB(0, 255, 0));\n  texture.clear();\n})\n\n代码的简单说明:\n为了更新窗口的渲染内容，我们需要在将代码包含在main loop(and after the event loop). clear()纹理，以至于它被填充绿色\n\n将窗口填充红色\ncanvas.set_draw_color(Color::RGB(255, 0, 0));\ncanvas.clear();\n将纹理拷贝到窗口中\ncanvas.copy(&square_texture, None, Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))\n      .expect(\"Couldn't copy texture into window\");\n最后更新窗口的展示\ncanvas.present();\n\n代码如下：\nextern crate sdl2;\n\nuse sdl2::event::Event;\nuse sdl2::keyboard::Keycode;\nuse sdl2::pixels::Color;\nuse sdl2::render::{Texture, TextureCreator};\nuse sdl2::rect::Rect;\nuse std::time::Duration;\n\nfn main() {\n     // 初始化SDL2\n     let sdl_context = sdl2::init().expect(\"SDL initialization failed\");\n     let video_subsystem = sdl_context.video().expect(\"Couldn't get SDL video subsystem\");\n\n     // 创建窗口和画布\n     let window = video_subsystem\n         .window(\"Tetris\", 800, 600)\n         .position_centered()\n         .build()\n         .expect(\"Failed to create window\");\n\n     let mut canvas = window.into_canvas()\n         .target_texture()\n         .present_vsync()\n         .build()\n         .expect(\"Couldn't get window's canvas\");\n\n     let texture_creator: TextureCreator&lt;_&gt; = canvas.texture_creator();\n     const TEXTURE_SIZE: u32 = 32;\n\n     // create a texture with a 32*32 size\n     let mut square_texture: Texture = texture_creator.create_texture_target(None, TEXTURE_SIZE, TEXTURE_SIZE)\n         .expect(\"Failed to create a texture\");\n\n     // use the canvas to draw into our square texture.\n     canvas.with_texture_canvas(&mut square_texture, |texture| {\n         // set the draw color to green\n         texture.set_draw_color(Color::RGB(0, 255, 0));\n         texture.clear();\n     }).expect(\"Failed to clear a texture\");\n\n     // 创建事件处理器\n     let mut event_pump = sdl_context.event_pump().expect(\"Failed to get SDL event pump\");\n\n     // 主循环\n     'runningloop: loop {\n         for event in event_pump.poll_iter() {\n             match event {\n                 Event::Quit { .. } | Event::KeyDown { keycode: Some(Keycode::Escape), .. } =&gt; {\n                     break 'runningloop;\n                 }\n                 _ =&gt; {}\n             }\n         }\n\n         // We set fulfill our window with red\n         canvas.set_draw_color(Color::RGB(255, 0, 0));\n         // We draw it\n         canvas.clear();\n         // Copy our texture into the window\n         canvas.copy(&square_texture, None, Rect::new(0, 0, TEXTURE_SIZE, TEXTURE_SIZE))\n             .expect(\"Couldn't copy texture into window\");\n         canvas.present();\n\n         // 添加延迟以控制帧率\n         std::thread::sleep(Duration::new(0, 1_000_000_000u32 / 60));\n     }\n}\n\n代码执行结果如下图所示:"
  },
  {
    "objectID": "posts/wasm_intro/index.html",
    "href": "posts/wasm_intro/index.html",
    "title": "WebAssembly简单介绍",
    "section": "",
    "text": "如果我问你：Javascript是什么？你的答案是什么？\n一种变成语言，对吗？\n这个答案是正确的但不完全正确。让我们看看是为什么？\n在当今世界，直接在浏览器里面写JS代码很少见。有时候你可能写Typescript并且转换成Javascript\n有时候你使用flutter构建web应用，也是将dart代码编译成Javascript，同样Kotlin，CoffeeScript, Elm等都是这样\n也就是说Javascript是唯一在浏览器上运行的编程语言(假设没有WASM)，任何想要针对浏览器和语言和框架都必须转为Javascript\n但Javascript不是被设计成编译目标(Compilation Target)，并且它没有针对此用例进行优化，WASM是更好的编译目标(Compilation Target)\n\n\n\nWebAssembly 是一种新型代码，可以在现代 Web 浏览器上运行， 它是一种低级代码具有紧凑二进制格式的类汇编语言，可以以接近本机的性能运行 并为 C/C++、C# 和 Rust 等语言提供编译目标，以便它们可以在网络上运行。\nWasm 和 WASI 之间的关系几乎与 JS 和 NodeJS 之间的关系相同。\n事实上，WASM 与 JS 一样，在浏览器沙箱内运行时的访问权限受到限制。\n例如，它无法读取系统上的文件或执行比 HTTP 更低级别的网络工作， 例如 TCP 和 UDP。 为什么，因为它的 API 不存在于浏览器上。\n\n\n\nWASI可以操作浏览器中不存在的系统API\nWasmTime的运行时(Runtime)可以在浏览器外以CLI程序的形式运行WASM文件。 这个用于系统任务(如读取文件和使用网络等)的WASM CLI程序使用WASI定义的标准。 这些标准与WASM本身一样，独立于平台，这一点非常重要。 以致于Docker的创建者在推特上写到：\nWASI不仅仅适用于云计算，未来我们还会看到需要WASM运行时才能运行的GUI和CLI程序，因为 通过这种方式，开发人员可以更轻松获得输出结果，并在一个操作系统上进行测试，然后就可以放心了。 因为他的程序在任何地方都能以同样的方式运行。"
  },
  {
    "objectID": "posts/wasm_intro/index.html#为什么需要wasm",
    "href": "posts/wasm_intro/index.html#为什么需要wasm",
    "title": "WebAssembly简单介绍",
    "section": "",
    "text": "如果我问你：Javascript是什么？你的答案是什么？\n一种变成语言，对吗？\n这个答案是正确的但不完全正确。让我们看看是为什么？\n在当今世界，直接在浏览器里面写JS代码很少见。有时候你可能写Typescript并且转换成Javascript\n有时候你使用flutter构建web应用，也是将dart代码编译成Javascript，同样Kotlin，CoffeeScript, Elm等都是这样\n也就是说Javascript是唯一在浏览器上运行的编程语言(假设没有WASM)，任何想要针对浏览器和语言和框架都必须转为Javascript\n但Javascript不是被设计成编译目标(Compilation Target)，并且它没有针对此用例进行优化，WASM是更好的编译目标(Compilation Target)"
  },
  {
    "objectID": "posts/wasm_intro/index.html#什么是wasm",
    "href": "posts/wasm_intro/index.html#什么是wasm",
    "title": "WebAssembly简单介绍",
    "section": "",
    "text": "WebAssembly 是一种新型代码，可以在现代 Web 浏览器上运行， 它是一种低级代码具有紧凑二进制格式的类汇编语言，可以以接近本机的性能运行 并为 C/C++、C# 和 Rust 等语言提供编译目标，以便它们可以在网络上运行。\nWasm 和 WASI 之间的关系几乎与 JS 和 NodeJS 之间的关系相同。\n事实上，WASM 与 JS 一样，在浏览器沙箱内运行时的访问权限受到限制。\n例如，它无法读取系统上的文件或执行比 HTTP 更低级别的网络工作， 例如 TCP 和 UDP。 为什么，因为它的 API 不存在于浏览器上。"
  },
  {
    "objectID": "posts/wasm_intro/index.html#什么是wasi",
    "href": "posts/wasm_intro/index.html#什么是wasi",
    "title": "WebAssembly简单介绍",
    "section": "",
    "text": "WASI可以操作浏览器中不存在的系统API\nWasmTime的运行时(Runtime)可以在浏览器外以CLI程序的形式运行WASM文件。 这个用于系统任务(如读取文件和使用网络等)的WASM CLI程序使用WASI定义的标准。 这些标准与WASM本身一样，独立于平台，这一点非常重要。 以致于Docker的创建者在推特上写到：\nWASI不仅仅适用于云计算，未来我们还会看到需要WASM运行时才能运行的GUI和CLI程序，因为 通过这种方式，开发人员可以更轻松获得输出结果，并在一个操作系统上进行测试，然后就可以放心了。 因为他的程序在任何地方都能以同样的方式运行。"
  },
  {
    "objectID": "posts/emacs_time_func/index.html",
    "href": "posts/emacs_time_func/index.html",
    "title": "Emacs获取当前系统时间生成文件名",
    "section": "",
    "text": "格式化当前时间函数\n\nFormat yyyy-mm-dd\n\n(format-time-string \"%Y-%m-%d\")\n;; \"2022-11-28\"\n\nUnix Time Format(number of seconds since 1970-01-01)\n\n(format-time-string \"%s\")\n;; \"1669620311\"\n\nNames for Month and Week\n\n(format-time-string \"%B\") ; \"November\"\n(format-time-string \"%b\") ; \"Nov\"\n(format-time-string \"%A\") ; \"Monday\"\n(format-time-string \"%a\") ; \"Tue\"\n\nTimezone\n\n(format-time-string \"%z\")\n\n\n拼接字符串(concat)\n(concat \"/path/to/root\" \"cur_dir\" \"file_name\" \".extend\")\n\n\n打开(创建)当天日期文件\n(open-file\n  (concat \"~/org\" (format-time-string \"%Y-%m-%d\") \".org\"))"
  },
  {
    "objectID": "posts/rust_notes/index.html",
    "href": "posts/rust_notes/index.html",
    "title": "Rust程序设计知识点",
    "section": "",
    "text": "很大程度上，Rust是围绕其类型设计的。\nRust对高性能代码的支持，源自它能让开发者原则最适合当前场景的数据表示法，在简单性与成本之间进行合理的权衡。\nRust的内存和线程安全保障也依赖于Rust类型系统的健全性。\nRust的灵活性则源自于其泛型类型和特型。\n\n\n\n\n基于已明确写出的类型，Rust的类型推断会帮你推断出剩下的大部分类型\n函数可以是泛型的：单个函数就可以处理许多不同类型的值\n\n\n\n\n\nRust类型系统的根基是一组固定宽度的数值类型，选用这些类型是为了匹配几乎所有现代处理器都已直接在硬件中实现的类型。 固定宽度的数值类型可能会溢出或丢失精度。\nchar既不是u8,也不是u32(尽管它确实有32位长)\nusize类型和isize类型类似于C和C++中的size_t和ptrdiff_t。它们的精度与目标机器上地址空间的大小保持一致， 即在32位架构上是32位长，在64位架构上则是64位长。\nRust要求数组索引是usize值。\n可以使用as运算符将一种整型转换成另一种整型。\nRust几乎不会执行任何隐式的数值转换，随时可以使用as运算符写出显式转换。\n\n\n\n\n\nRust非常严格\n\n像if和while这样的控制结构要求它们的条件必须是bool表达式\n短路逻辑运算符&&和||也是如此\n\n\n\n\n\n\nRust的字符类型char会以32位值表示单个Unicode字符\nRust会对单独的字符使用char类型，但对字符串和文本流使用UTF-8编码\nu8是唯一能通过as运算符转换为char的类型\n\n\n\n\n\nRust有多种表示内存地址的类型，这是Rust和大多数具有垃圾回收功能的语言之间一个重大差异。\nRust语言旨在帮你将内存分配保持在最低限度。\n\n\n\n\n\n将引用视为Rust中的基本指针类型\nRust引用有两种形式\n\n&T: 一个不可变的共享引用\n&mut T: 一个可变的、独占的引用\n\nRust利用共享引用和可变引用之间的”二选一”机制来强制执行”单个写入者或多个读取者”规则\n你独占读写一个值，或者让任意数量的读取者共享，但二者只能选择其一\n这种由编译期检查强制执行的”二选一”规则是Rust安全保障的核心\n\n\n\n\n\nRust用3种类型来表示内存中的值序列\n\n类型[T;N]表示N个值的数组，每个值的类型为T，N在编译期已经确定，不能追加新元素或缩小数组\n类型Vec&lt;T&gt;可称为T的向量，它是一个动态分配且可增长的T类型的值序列\n类型&[T]和&mut [T]可称为T的共享切片和T的可变切片\n\n在数组上看到的那些使用方法都是作为切片而非数组的方法提供的\n\n包括：遍历、搜索、排序、填充、过滤等\nRust在搜索各种方法时会隐式地将对数组的引用转换为切片，因此可以直接在数组上调用任何切片的方法\nsort方法实际上是在切片上定义的\nlen方法也是切片的方法之一\n\n向量\n\n使用collect时，通常要指定类型，因为它可以构建出不同种类的集合，而不仅仅是向量\n与数组一样，可以对向量使用切片的方法\n\nreverse方法实际上是在切片上定义的，此调用会隐式地从向量中借用一个&mut [&str]切片并在其上调用reverse\n\nVec是Rust的基本数据类型，它几乎可以用在任何需要动态大小的列表的地方\n如果事先知道向量所需的元素数量，就可以调用Vec::with_capacity而不是Vec::new来创建一个向量，它的缓冲区足够大，可以从一开始就容纳所有元素\n许多库函数会寻求使用Vec::with_capacity而非Vec::new的机会\n\n切片\n\n切片是数组或向量中的一个区域\n对切片的引用是一个胖指针\n\n一个双字值\n包括指向切片第一个元素的指针和切片中元素的数量\n\n\n\n\n\n\n\n字符串字面量\n\n原始字符串用小写字母r进行标记，原始字符串不识别任何转义序列\n可以再原始字符串的开头和结尾添加#做标记\n\n字符串\n\n带有b前缀的字符串字面量都是字节串，这样的字节串是u8值(字节)的切片而不是Unicode文本\nlet method = b\"POST\";  // method类型是&[u8; 4]\nassert_eq!(method, &[b'P', b'O', b'S', b'T']);\n字节串不能包含任意Unicode字符，它们只能使用ASCII和\\xHH转义序列\n\n内存中的字符串\n\nRust字符串是Unicode字符序列，但并不以char数组的形式存储在内存中，而是用了UTF-8形式(可变宽度编码)\nString或&str的.len()方法会返回其长度\n&mut str类型确实存在，但它没什么用\n&mut str上唯一可用的操作是make_ascii_uppercase和make_ascii_lowercase，根据定义，它们会就地修改文本并且只影响单字节字符\n\nString\n\n&str非常像&[T],是指向某些数据的胖指针\n而String则类似于Vec&lt;T&gt;\nString有几种方法\n\n.to_string()方法会将&str转换为String，这会复制此字符串\n.to_owned()方法会做同样的事情，也会以同样的方式使用\nformat!()宏的工作方式与println!()类似，但它会返回一个新的String\n.concat()和.json(sep)，字符串数组、切片、向量都有这两个方法，它们会从许多字符串中形成一个新的String\n\n\n其它类似字符串的类型\n\n对于Unicode文本，坚持使用String和&str\n当使用文件名，请改用std::path::PathBuf和&Path\n当处理根本不是UTF-8编码的二进制数据时，请使用Vec&lt;u8&gt;和&[u8]\n当使用操作系统提供的原生形式环境变量名和命令行参数时，请使用OsString和&OsStr\n当和使用null结尾字符串的C语言库进行互操作时，请使用std::ffi::CString和&CStr\n\n\n\n\n\n\n谈及内存管理，我们希望编程语言具备两个特点\n\n能在我们选定的时机及时释放，这使得我们能控制程序的内存消耗\n对象被释放后，绝不希望继续使用使用指向它的指针，这是未定义行为，会导致崩溃和安全漏洞\n\n几乎所有主流编程语言都只能在两个阵营”二选一”\n\n安全优先：通过垃圾回收机制，在所有指向对象的可达指针都消失后，自动释放对象\n控制优先：让开发者自己负责释放内存，程序的内存消耗完全掌握在开发者受众。\n\nRust通过限制程序使用指针的方式出人意料的打破了这种困局\n\n在运行期，指针仅仅是内存中的地址，和在C与C++中一样\n而不一样的是，Rust编译器已然证明你的代码在安全地使用它们\n\n所有权\n\n每个值都有唯一的拥有者\n拥有者及其拥有的哪些值形成了一棵树\n\n值的拥有者是值的父节点\n值拥有的值是子节点\n每棵树的总根都是一个变量\n当该变量超出作用域时，整棵树都将随之消失\n\nRust的单一拥有者规则将禁止任何可能让它们排列得比树结构更复杂的可能性\nRust程序中的每一个值都是某棵树的成员，树根是某个变量\n\n为了处理某些场景，Rust从几个方面扩展了这种简单的思想\n\n可以将值从一个拥有者转移给另一个拥有者，\n\n允许你构建、重新排列和拆除树形结构\n\n像整型、浮点数和字符这样的非常简单的类型，不受所有权规则的约束\n\n这些称为Copy类型\n\n标准库提供了引用计数指针类型Rc和Arc，它们允许在某些限制下有多个拥有者\n可以对值进行”借用”(borrow)，以获得值的引用。\n\n这种引用是非拥有型指针，有着受限的生命周期\n\n\n移动\n\n对大多数类型来说，像为变量复制、将其传给函数或从函数返回的操作都不会复制值，而是移动值。\n源会把值的所有权转移给目标并变回未初始化状态，改由目标变量来控制值的生命周期\n\n将参数传给函数会将所有权转移给函数的参数\n从函数返回一个值会将所有权转给调用者\n构建元组会将值转给元组\n\n值移动涉及字符串、向量和其他占用大量内存且复制成本高昂的类型\n移动让这些类型的所有权清晰且赋值开销极低\n\nCopy类型：关于移动的例外情况\n\n对于Copy类型的值进行赋值会复制这个值，而不会移动它\n赋值的源仍会保持已初始化和可用状态，并且具有与之前相同的值\n标准的Copy类型包括：\n\n整数类型、浮点类型、char类型、bool类型，以及其他类型\n\n任何在丢弃值时需要做一些特殊操作的类型都不能是Copy类型\n如果结构体的所有字段都是Copy类型，那么可以通过属性#[derive(Copy,Clone)]放置在此定义之上来创建Copy类型\nRust的一个原则是：\n\n各种开销对程序员来说应该是显而易见的\n基本操作必须保持简单，而潜在的昂贵操作应该是显式的\n\n\nRc与Arc：共享所有权\n\nRc和Arc非常相似，唯一的区别是Arc可以安全地在线程之间直接共享\n普通Rc会使用更快的非线程安全代码来更新引用计数\n克隆一个Rc&lt;T&gt;值并不会复制T，相反，它只会创建另一个指向它的指针并通过递增引用计数\n通常的所有权规则适用于Rc指针本身，当丢弃最后一个Rc时，Rust也会丢弃T\n\n资源交给Rc管理，Rc不存在后则一切都不存在了\n\nRust的内存和线程安全保证的基石是:\n\n确保不会有任何值时既共享又可变的\nRust假Rc指针的引用目标通常都可以共享，因此就不能是可变的\n\n弱引用指针std::rc::Weak来避免建立Rc指针循环。\n\n小结\n\n所有权：每个值有唯一的所有者\n移动：涉及特殊操作的赋值会发生所有权转移\nCopy：简单类型的赋值操作会复制值\nRc和Arc：共享值的所有权\n移动和引用计数指针是缓解所有权严格性问题的两种途径\n第三种途径是借用对值的引用\n\n\n\n\n\n\n迄今为止，我们所看到的所有指针类型都是拥有型指针，意味着当拥有者被丢弃时，它的引用目标也会随之消失\n\n如：简单的Box&lt;T&gt;堆指针，String值，Vec值内部的指针\n\nRust还有一种名为引用(reference)的非拥有型指针，这种指针对引用目标的生命周期毫无影响\n引用的生命周期决不能超出其引用目标\nRust把创建对某个值的引用的操作称为借用(borrow)那个值：凡是借用，终须归还\n引用本身确实没什么特别之处-说到底，它们只是地址而已\n\n但用以让引用保持安全的规则，对Rust来说是一种创新\n\n\n\n对值的引用\n\n引用能让在不影响其所有权的情况下访问值\n\n共享引用：允许你读取但不能修改其引用目标，可以同时拥有任意数量对特定值的共享引用。\n\n类型写成：&T\n共享引用是Copy类型\n\n可变引用：允许你读取和修改值，一旦一个值拥有了可变引用，就无法对该值创建其它任何引用。\n\n类型写成: &mut T\n可变引用不是Copy类型\n\n\n可以将共享引用和可变引用之间的区别视为在编译期强制执行多重读取或单一写入\n\n这条规则不仅适用于引用，也适用于所引用值的拥有者\n只要存在一个值的共享引用，即使是它的拥有者也不能修改它，该值会被锁定\n\n事实证明：让共享和修改保证完全分离对内存安全至关重要\n\n由于引用在Rust中随处可见，因此.运算符就会按需对其左操作数隐式解引用\nstruct Anime { name: &'static str, bechdel_pass: bool};\nlet aria = Anime { name: \"Aria: The Animation\", bechdel_pass: true};\nlet anime_ref = &aria;\nassert_eq!(anime_ref.name, \"Aria: The Animation\");\n\n在Rust中使用&运算符和*运算符来创建引用(借用)和追踪引用(解引用),不过.运算符不需要做这种转换，它会隐式借用和解引用\n\n对引用进行引用\nstruct Point {x: i32, y: i32};\nlet point = Point {x: 1000, y: 729};\nlet r: &Point = &point;\nlet rr: &&Point = &r;\nlet rrr: &&&Point = &rr;\n\n.运算符会追踪尽可能多层次的引用来找到它的目标\n\n比较引用\n\n就像.运算符一样，Rust的比较运算符也能看穿任意数量的引用\n比较运算符操作数(包括引用型操作数)必须是完全相同类型\n\n比如如上代码中r与rr类型不匹配\n\n两个引用是否指向同一块内存，可以使用std::ptr::eq，会对两者作为地址进行比较\n\n引用永不为空\n\n在Rust中，如果需要用一个值来表示对某个可能不存在事物的引用，请使用Option&lt;&T&gt;\n在机器级别，Rust会将None表示为空指针，将Some(r)表示为非零地址，因此Option&lt;&T&gt;与C/C++中的可空指针一样高效，但更安全\n\n它的类型要求你在使用之前必须检查它是否为None\n\n\n对切片和特型对象的引用\n\nRust还包括两种胖指针，即携带某个值地址的双字值，以及要正确使用该值所需的某些额外信息\n\n对切片的引用就是一个胖指针，携带着此切片的起始地址及其长度\n另一种胖指针是特型对象，即对实现了指定型的值的引用\n\n\nRust的可变与共享规则\n\n共享访问是只读访问\n\n对于共享借用，这条路径是只读的\n\n可变访问是独占访问\n\n对于可变借用，这条路径是完全不可访问的\n通过要求可变访问必须是独占的，Rust避免了一大类日常错误\n\n在编写并发代码时，共享引用和可变引用的互斥性确实证明了其价值\n\n\n\n\n\n\nRust中完全面向表达式的控制流\n\nif表达式可用于初始化变量\nmatch表达式可以作为参数传给函数或宏\n块是一种最通用的表达式，一个块生成一个值\nif let表达式其实只有一个模式的match表达式的简写形式\nmatch表达式的所有分支都必须具有相同的类型\nwhile循环或for循环的值总是()\nloop表达式就能生成一个值\n\nloop中所有break表达式也必须生成具有相同类型的值，这样该类型就会成为这个loop本身的类型\n\n..运算符会生成一个范围(range)，即具有两个字段(start和end)的简单结构体\nbreak表达式会退出所在循环\n\n几个重要的自动转换\n\n&String类型的值会自动转换为&str类型，无须强制转换\n&Vec&lt;i32&gt;类型的值会自动转换为&[i32]\n&Box&lt;Chessboard&gt;类型的值自动转换为&Chessboard\n以上这些被称为隐式解引用，因为它们适用于所有实现了内置特型Deref的类型\n\nDeref隐式转换的目的是使智能指针类型的行为尽可能像其底层值\n多亏了Deref，Box&lt;Chessboard&gt;的用法基本上和普通Chessboard的用法一样\n\n\n\n\n\n\n\ncrate\n\n每个crate都是既完整又内聚的单元\n包含单个库或可执行程序的所有源代码\n\ncrate是关于项目间代码共享的，而模块是关于项目内代码组织的\n\n它们(crate与module)扮演着Rust命名空间的角色，是构成Rust程序或库的函数、类型、常量等的容器\n\n函数标记为pub(crate)\n\n那么就意味着它可以再这个crate的任何地方使用\n但不会作为外部接口的一部分公开\n\n预导入(prelude)\n\n它们通过收集几乎所有用户都需要的常用导入，减少了样板代码的编写\n把一个模块命名为prelude只是一种约定，旨在告诉用户应该使用*导入它\n\n模块\n\n目录可以作为一个模块，目录名为模块名\n\n目录中包含mod.rs,表示是一个模块，类似Python语言的__init__.py\n\n文件可以作为一个模块，文件名为模块名\n自定义文件中的模块\n\n使用mod关键字\n\n::运算符用于访问模块中的各项特型\n关键字super和crate在路径中有着特殊的含义\n\nsuper指的是父模块\ncrate指的是当前模块所在的crate\n\nas关键字可以给导入的内容重命名\n绝对路径\n\n以::开头，总会引用外部crate\n\nsrc/lib.rs中代码构成了库的根模块\n\n\n\n\n\n\nRust有三种结构体类型\n\n具名字段型结构体\n元组型结构体\n单元型结构体\n\n具名字段型结构体\n\nRust中的约定是\n\n所有类型(包括结构体)的名称都将每个单词的第一个字母大写，称为大驼峰式\n字段和方法是小写的，单词之间用下划线分隔，称为蛇形格式\n\n结构体默认情况下是私有的\n\n仅在声明它们的模块及其子模块中可见\n即使一个结构体声明为pub，它的字段也可以是私有的\n其它模块可以使用此结构体及其任何公共的关联函数，但不能按名称访问私有字段或使用结构体表达式创建新值\n\n\n用impl定义方法\n\nimpl块只是fn定义的集合，每个定义都会成为块顶部命名的结构体类型上的一个方法\n在impl块中定义的函数称为关联函数，因为它们是与特定类型相关联的\nRust会将调用关联函数的结构体值作为第一个参数传给方法\n\n该参数必须具有特殊名称self\n由于self的类型显然就是在impl块顶部命名的类型或对该类型的引用\nself的不同形式\n\nself\n&self\n&mut self\n\n\n\n以Box、Rc或Arc形式传入self\n\n方法的self参数也可以是Box&lt;Self&gt;类型，Rc&lt;Self&gt;类型或Arc&lt;Self&gt;类型\nRust会自动从Box、Rc、Arc等指针类型中借入引用\n\n因此&self和&mut self几乎总是方法签名里的正确选择\n\n\n类型关联函数\n\nimpl块还可以定义根本不以self参数的函数\n这些函数仍然是关联函数，因为它们在impl块中\n但它们不是方法，因为它们不接受self参数\n为了将它们与方法区分开来，我们称其为类型关联函数\n\n泛型结构体\n\nRust结构体可以是泛型的\n\n在泛型结构体定义中，尖括号(&lt;&gt;)中的类型名称叫作类型参数\nSelf参数定义为我们要为其添加方法的任意类型。\n调用关联函数时，使用::&lt;&gt;(比目鱼)表示法显式地提供类型参数\n\n\n带生命周期参数的泛型结构体\n\n如果结构体类型包括引用，则必须为这些引用的生命周期命名\n\n带常量参数的泛型结构体\n\n常量泛型参数可以是任意整数类型、char或bool\n不允许使用浮点数、枚举和其他类型\n如果结构体还接受其他种类的泛型参数\n\n则生命周期参数必须排在第一位，然后是类型，接下来是任何const值\n\n\n内部可变性\n\n我们需要一个不可变值中的一丁点儿可变数据，称为内部可变性\nCell&lt;T&gt;是一个包含类型T的单个私有值的结构体\nCell唯一的特殊之处在，即使你对Cell本身没有mut访问权限，也可以获取和设置这个私有字段\nCell只是改变不变性规则的一种安全方式\n\n一丝不多，一毫不少\nCell不允许在共享值上调用mut方法\n.get()方法会返回Cell中值的副本，因此它仅在T实现了Copy特型时才有效\n\nCell很容易使用\n\n虽然不得不调用.get()和.set()或.borrow()和.borrow_mut()略显尴尬\n但这就是我们为违反规则而付出的代价\n\nCell不是线程安全的\n与Cell不用，RefCell支持借用对其T值的引用\n\n\n\n\n\n\nRust模式有点像针对所有数据的正则表达式\n枚举可以是泛型的，如Option&lt;T&gt;,Result&lt;T&gt;\n只能用一种安全的方式来访问枚举中的数据，即使用模式\nmatch表达式中，模式就是出现在=&gt;符号前面的部分\n表达式会生成值，模式会消耗值\n模式匹配可以和枚举协同工作，甚至可以测试它们包含的数据，这让match成了C的switch语句的强大而灵活的替代品\nmatch也可用来匹配其他类型\n\n字面量、变量、通配符等\n字面量也可以用作模式，包括布尔值、字符，甚至字符串\n不关心匹配的值，那么可以用单个下划线_作为模式，这就是通配符模式\n\n元组型模式匹配元组\n结构体型模式使用花括号，就像结构体表达式一样\n数组型模式与切片模式\n\n切片模式不仅匹配值，还匹配长度\n\n引用型模式\n\nref模式会借用己匹配值的一部分\n&模式会匹配引用`\n匹配不可复制的值会移动该值\n\n\n\n\n\n\nRust通过两个相关联的特性来支持多态\n\n特型和泛型\n\n特型\n\n是Rust体系中的接口或抽象基类\n是一种语言特性，我们可以说某类型支持或不支持某个特型\n大多数情况下，特型代表着一种能力，即一个类型能做什么\n特型本身必须在作用域内\n\nClone和Iterator的各个方法没有导入就能工作，因为默认它们始终在作用域中，是标准库一部分\n预导入主要就是一些精心挑选的特型\n\n\n泛型\n\n是Rust中多态的另一种形式\n\n界限\n\n对类型T可能的类型范围做了限制\n\n泛型和特型的紧密相关\n\n泛型函数会在限界中使用特型来阐明它能针对哪些类型的参数进行调用\n\n\n\n为什么向类型添加特型不需要额外的内存，以及如何在不需要虚方法调用开销的情况下使用特型\n特型对象\n\n在Rust中使用特型编写多态代码有两种方式：\n\n特型对象\n泛型\n\n对特型类型的引用叫作特型对象\nRust通常无法在编译期间知道引用目标的类型，因此特性对象要包含一些关于引用目标类型的额外信息\n特型对象的内存布局\n\n特型对象是一个胖指针\n由指向值的指针和指向表示该值类型的虚表的指针组成\n在Rust中，虚表只会在编译期生成一次，并由同一类型的所有对象共享\n当调用特型对象的方法时，该语言会自动使用虚表来确定调用哪个实现\n在C++中，虚表指针或vptr是作为结构体的一部分存储，而Rust是胖指针方案\nRust中，结构体本身只包含自己的字段\n\n这样一来，每个结构体就可以实现几十个特型而不必包含几十个vptr了\n\nRust在需要时会自动将普通引用转换为特型对象\n创建特型对象的唯一方法\n\n&mut dyn train_name\n&mut dyn Write和Box&lt;dyn Write&gt;也是一个胖指针，包含写入器本身的地址和虚表的地址\n\n\n\n特型对象还是泛型代码的选择相当微妙\n\n由于这两个特性都基于特型\n当需要一些混合类型值的集合时，特型对象是正确的选择\n\n与特型对象相比，泛型具有三个重要优势\n\n第一个优势是速度，没有dyn则不会有动态派发，没有运行期开销\n第二个优势在于并不是每个特性都能支持特型对象\n第三个优势是它很容易同时指定具有多个特型和泛型参数限界，特型对象不能这样\n\n定义与实现特型\n\n定义特型很简单，给它一个名字并列出特型方法的类型签名即可\n要实现特型，请使用语法impl TraitName for Type\n特型的impl代码中定义一切都必须是真正属于此特型的\n自定义函数不能放在特型的impl代码中，只能包含在单独的impl块中\n特型的impl代码中的一切都必须是真正属于此特型\n特型中有未实现的函数，也有已实现的函数\n\n特型中的Self\n\n特型可以用关键字Self作为类型\n使用了Self类型的特型与特型对象不兼容\n特型对象实际上是为最简单的特型类型而设计的\n特型的高级特性很有用，但它们不能与特型对象共存\n\n因为一旦有了特型对象，就会失去Rust对你的程序进行类型检查时所必须的类型信息\n\n\nimpl Trait\n\n是一种静态派发形式\nRust不允许特型方法使用impl Trait作为返回值\n只有最简单的泛型函数中才能把impl Trait参数用作类型，参数的类型之间不能存在关系\n\n类型限界的另一个优点\n\n当遇到编译期错误时，至少编译期可以告诉你问题出在哪里\n限界就这么写在代码和文档中，你可以查看Rust中泛型函数的签名\n并准确了解它能接受的参数类型\n而使用模版则做不到这些\n\n以特型为基础\n\n特型和泛型在所有这些主题中都扮演着核心角色"
  },
  {
    "objectID": "posts/rust_notes/index.html#基本数据类型",
    "href": "posts/rust_notes/index.html#基本数据类型",
    "title": "Rust程序设计知识点",
    "section": "",
    "text": "很大程度上，Rust是围绕其类型设计的。\nRust对高性能代码的支持，源自它能让开发者原则最适合当前场景的数据表示法，在简单性与成本之间进行合理的权衡。\nRust的内存和线程安全保障也依赖于Rust类型系统的健全性。\nRust的灵活性则源自于其泛型类型和特型。\n\n\n\n\n基于已明确写出的类型，Rust的类型推断会帮你推断出剩下的大部分类型\n函数可以是泛型的：单个函数就可以处理许多不同类型的值\n\n\n\n\n\nRust类型系统的根基是一组固定宽度的数值类型，选用这些类型是为了匹配几乎所有现代处理器都已直接在硬件中实现的类型。 固定宽度的数值类型可能会溢出或丢失精度。\nchar既不是u8,也不是u32(尽管它确实有32位长)\nusize类型和isize类型类似于C和C++中的size_t和ptrdiff_t。它们的精度与目标机器上地址空间的大小保持一致， 即在32位架构上是32位长，在64位架构上则是64位长。\nRust要求数组索引是usize值。\n可以使用as运算符将一种整型转换成另一种整型。\nRust几乎不会执行任何隐式的数值转换，随时可以使用as运算符写出显式转换。\n\n\n\n\n\nRust非常严格\n\n像if和while这样的控制结构要求它们的条件必须是bool表达式\n短路逻辑运算符&&和||也是如此\n\n\n\n\n\n\nRust的字符类型char会以32位值表示单个Unicode字符\nRust会对单独的字符使用char类型，但对字符串和文本流使用UTF-8编码\nu8是唯一能通过as运算符转换为char的类型\n\n\n\n\n\nRust有多种表示内存地址的类型，这是Rust和大多数具有垃圾回收功能的语言之间一个重大差异。\nRust语言旨在帮你将内存分配保持在最低限度。\n\n\n\n\n\n将引用视为Rust中的基本指针类型\nRust引用有两种形式\n\n&T: 一个不可变的共享引用\n&mut T: 一个可变的、独占的引用\n\nRust利用共享引用和可变引用之间的”二选一”机制来强制执行”单个写入者或多个读取者”规则\n你独占读写一个值，或者让任意数量的读取者共享，但二者只能选择其一\n这种由编译期检查强制执行的”二选一”规则是Rust安全保障的核心\n\n\n\n\n\nRust用3种类型来表示内存中的值序列\n\n类型[T;N]表示N个值的数组，每个值的类型为T，N在编译期已经确定，不能追加新元素或缩小数组\n类型Vec&lt;T&gt;可称为T的向量，它是一个动态分配且可增长的T类型的值序列\n类型&[T]和&mut [T]可称为T的共享切片和T的可变切片\n\n在数组上看到的那些使用方法都是作为切片而非数组的方法提供的\n\n包括：遍历、搜索、排序、填充、过滤等\nRust在搜索各种方法时会隐式地将对数组的引用转换为切片，因此可以直接在数组上调用任何切片的方法\nsort方法实际上是在切片上定义的\nlen方法也是切片的方法之一\n\n向量\n\n使用collect时，通常要指定类型，因为它可以构建出不同种类的集合，而不仅仅是向量\n与数组一样，可以对向量使用切片的方法\n\nreverse方法实际上是在切片上定义的，此调用会隐式地从向量中借用一个&mut [&str]切片并在其上调用reverse\n\nVec是Rust的基本数据类型，它几乎可以用在任何需要动态大小的列表的地方\n如果事先知道向量所需的元素数量，就可以调用Vec::with_capacity而不是Vec::new来创建一个向量，它的缓冲区足够大，可以从一开始就容纳所有元素\n许多库函数会寻求使用Vec::with_capacity而非Vec::new的机会\n\n切片\n\n切片是数组或向量中的一个区域\n对切片的引用是一个胖指针\n\n一个双字值\n包括指向切片第一个元素的指针和切片中元素的数量\n\n\n\n\n\n\n\n字符串字面量\n\n原始字符串用小写字母r进行标记，原始字符串不识别任何转义序列\n可以再原始字符串的开头和结尾添加#做标记\n\n字符串\n\n带有b前缀的字符串字面量都是字节串，这样的字节串是u8值(字节)的切片而不是Unicode文本\nlet method = b\"POST\";  // method类型是&[u8; 4]\nassert_eq!(method, &[b'P', b'O', b'S', b'T']);\n字节串不能包含任意Unicode字符，它们只能使用ASCII和\\xHH转义序列\n\n内存中的字符串\n\nRust字符串是Unicode字符序列，但并不以char数组的形式存储在内存中，而是用了UTF-8形式(可变宽度编码)\nString或&str的.len()方法会返回其长度\n&mut str类型确实存在，但它没什么用\n&mut str上唯一可用的操作是make_ascii_uppercase和make_ascii_lowercase，根据定义，它们会就地修改文本并且只影响单字节字符\n\nString\n\n&str非常像&[T],是指向某些数据的胖指针\n而String则类似于Vec&lt;T&gt;\nString有几种方法\n\n.to_string()方法会将&str转换为String，这会复制此字符串\n.to_owned()方法会做同样的事情，也会以同样的方式使用\nformat!()宏的工作方式与println!()类似，但它会返回一个新的String\n.concat()和.json(sep)，字符串数组、切片、向量都有这两个方法，它们会从许多字符串中形成一个新的String\n\n\n其它类似字符串的类型\n\n对于Unicode文本，坚持使用String和&str\n当使用文件名，请改用std::path::PathBuf和&Path\n当处理根本不是UTF-8编码的二进制数据时，请使用Vec&lt;u8&gt;和&[u8]\n当使用操作系统提供的原生形式环境变量名和命令行参数时，请使用OsString和&OsStr\n当和使用null结尾字符串的C语言库进行互操作时，请使用std::ffi::CString和&CStr\n\n\n\n\n\n\n谈及内存管理，我们希望编程语言具备两个特点\n\n能在我们选定的时机及时释放，这使得我们能控制程序的内存消耗\n对象被释放后，绝不希望继续使用使用指向它的指针，这是未定义行为，会导致崩溃和安全漏洞\n\n几乎所有主流编程语言都只能在两个阵营”二选一”\n\n安全优先：通过垃圾回收机制，在所有指向对象的可达指针都消失后，自动释放对象\n控制优先：让开发者自己负责释放内存，程序的内存消耗完全掌握在开发者受众。\n\nRust通过限制程序使用指针的方式出人意料的打破了这种困局\n\n在运行期，指针仅仅是内存中的地址，和在C与C++中一样\n而不一样的是，Rust编译器已然证明你的代码在安全地使用它们\n\n所有权\n\n每个值都有唯一的拥有者\n拥有者及其拥有的哪些值形成了一棵树\n\n值的拥有者是值的父节点\n值拥有的值是子节点\n每棵树的总根都是一个变量\n当该变量超出作用域时，整棵树都将随之消失\n\nRust的单一拥有者规则将禁止任何可能让它们排列得比树结构更复杂的可能性\nRust程序中的每一个值都是某棵树的成员，树根是某个变量\n\n为了处理某些场景，Rust从几个方面扩展了这种简单的思想\n\n可以将值从一个拥有者转移给另一个拥有者，\n\n允许你构建、重新排列和拆除树形结构\n\n像整型、浮点数和字符这样的非常简单的类型，不受所有权规则的约束\n\n这些称为Copy类型\n\n标准库提供了引用计数指针类型Rc和Arc，它们允许在某些限制下有多个拥有者\n可以对值进行”借用”(borrow)，以获得值的引用。\n\n这种引用是非拥有型指针，有着受限的生命周期\n\n\n移动\n\n对大多数类型来说，像为变量复制、将其传给函数或从函数返回的操作都不会复制值，而是移动值。\n源会把值的所有权转移给目标并变回未初始化状态，改由目标变量来控制值的生命周期\n\n将参数传给函数会将所有权转移给函数的参数\n从函数返回一个值会将所有权转给调用者\n构建元组会将值转给元组\n\n值移动涉及字符串、向量和其他占用大量内存且复制成本高昂的类型\n移动让这些类型的所有权清晰且赋值开销极低\n\nCopy类型：关于移动的例外情况\n\n对于Copy类型的值进行赋值会复制这个值，而不会移动它\n赋值的源仍会保持已初始化和可用状态，并且具有与之前相同的值\n标准的Copy类型包括：\n\n整数类型、浮点类型、char类型、bool类型，以及其他类型\n\n任何在丢弃值时需要做一些特殊操作的类型都不能是Copy类型\n如果结构体的所有字段都是Copy类型，那么可以通过属性#[derive(Copy,Clone)]放置在此定义之上来创建Copy类型\nRust的一个原则是：\n\n各种开销对程序员来说应该是显而易见的\n基本操作必须保持简单，而潜在的昂贵操作应该是显式的\n\n\nRc与Arc：共享所有权\n\nRc和Arc非常相似，唯一的区别是Arc可以安全地在线程之间直接共享\n普通Rc会使用更快的非线程安全代码来更新引用计数\n克隆一个Rc&lt;T&gt;值并不会复制T，相反，它只会创建另一个指向它的指针并通过递增引用计数\n通常的所有权规则适用于Rc指针本身，当丢弃最后一个Rc时，Rust也会丢弃T\n\n资源交给Rc管理，Rc不存在后则一切都不存在了\n\nRust的内存和线程安全保证的基石是:\n\n确保不会有任何值时既共享又可变的\nRust假Rc指针的引用目标通常都可以共享，因此就不能是可变的\n\n弱引用指针std::rc::Weak来避免建立Rc指针循环。\n\n小结\n\n所有权：每个值有唯一的所有者\n移动：涉及特殊操作的赋值会发生所有权转移\nCopy：简单类型的赋值操作会复制值\nRc和Arc：共享值的所有权\n移动和引用计数指针是缓解所有权严格性问题的两种途径\n第三种途径是借用对值的引用\n\n\n\n\n\n\n迄今为止，我们所看到的所有指针类型都是拥有型指针，意味着当拥有者被丢弃时，它的引用目标也会随之消失\n\n如：简单的Box&lt;T&gt;堆指针，String值，Vec值内部的指针\n\nRust还有一种名为引用(reference)的非拥有型指针，这种指针对引用目标的生命周期毫无影响\n引用的生命周期决不能超出其引用目标\nRust把创建对某个值的引用的操作称为借用(borrow)那个值：凡是借用，终须归还\n引用本身确实没什么特别之处-说到底，它们只是地址而已\n\n但用以让引用保持安全的规则，对Rust来说是一种创新\n\n\n\n对值的引用\n\n引用能让在不影响其所有权的情况下访问值\n\n共享引用：允许你读取但不能修改其引用目标，可以同时拥有任意数量对特定值的共享引用。\n\n类型写成：&T\n共享引用是Copy类型\n\n可变引用：允许你读取和修改值，一旦一个值拥有了可变引用，就无法对该值创建其它任何引用。\n\n类型写成: &mut T\n可变引用不是Copy类型\n\n\n可以将共享引用和可变引用之间的区别视为在编译期强制执行多重读取或单一写入\n\n这条规则不仅适用于引用，也适用于所引用值的拥有者\n只要存在一个值的共享引用，即使是它的拥有者也不能修改它，该值会被锁定\n\n事实证明：让共享和修改保证完全分离对内存安全至关重要\n\n由于引用在Rust中随处可见，因此.运算符就会按需对其左操作数隐式解引用\nstruct Anime { name: &'static str, bechdel_pass: bool};\nlet aria = Anime { name: \"Aria: The Animation\", bechdel_pass: true};\nlet anime_ref = &aria;\nassert_eq!(anime_ref.name, \"Aria: The Animation\");\n\n在Rust中使用&运算符和*运算符来创建引用(借用)和追踪引用(解引用),不过.运算符不需要做这种转换，它会隐式借用和解引用\n\n对引用进行引用\nstruct Point {x: i32, y: i32};\nlet point = Point {x: 1000, y: 729};\nlet r: &Point = &point;\nlet rr: &&Point = &r;\nlet rrr: &&&Point = &rr;\n\n.运算符会追踪尽可能多层次的引用来找到它的目标\n\n比较引用\n\n就像.运算符一样，Rust的比较运算符也能看穿任意数量的引用\n比较运算符操作数(包括引用型操作数)必须是完全相同类型\n\n比如如上代码中r与rr类型不匹配\n\n两个引用是否指向同一块内存，可以使用std::ptr::eq，会对两者作为地址进行比较\n\n引用永不为空\n\n在Rust中，如果需要用一个值来表示对某个可能不存在事物的引用，请使用Option&lt;&T&gt;\n在机器级别，Rust会将None表示为空指针，将Some(r)表示为非零地址，因此Option&lt;&T&gt;与C/C++中的可空指针一样高效，但更安全\n\n它的类型要求你在使用之前必须检查它是否为None\n\n\n对切片和特型对象的引用\n\nRust还包括两种胖指针，即携带某个值地址的双字值，以及要正确使用该值所需的某些额外信息\n\n对切片的引用就是一个胖指针，携带着此切片的起始地址及其长度\n另一种胖指针是特型对象，即对实现了指定型的值的引用\n\n\nRust的可变与共享规则\n\n共享访问是只读访问\n\n对于共享借用，这条路径是只读的\n\n可变访问是独占访问\n\n对于可变借用，这条路径是完全不可访问的\n通过要求可变访问必须是独占的，Rust避免了一大类日常错误\n\n在编写并发代码时，共享引用和可变引用的互斥性确实证明了其价值\n\n\n\n\n\n\nRust中完全面向表达式的控制流\n\nif表达式可用于初始化变量\nmatch表达式可以作为参数传给函数或宏\n块是一种最通用的表达式，一个块生成一个值\nif let表达式其实只有一个模式的match表达式的简写形式\nmatch表达式的所有分支都必须具有相同的类型\nwhile循环或for循环的值总是()\nloop表达式就能生成一个值\n\nloop中所有break表达式也必须生成具有相同类型的值，这样该类型就会成为这个loop本身的类型\n\n..运算符会生成一个范围(range)，即具有两个字段(start和end)的简单结构体\nbreak表达式会退出所在循环\n\n几个重要的自动转换\n\n&String类型的值会自动转换为&str类型，无须强制转换\n&Vec&lt;i32&gt;类型的值会自动转换为&[i32]\n&Box&lt;Chessboard&gt;类型的值自动转换为&Chessboard\n以上这些被称为隐式解引用，因为它们适用于所有实现了内置特型Deref的类型\n\nDeref隐式转换的目的是使智能指针类型的行为尽可能像其底层值\n多亏了Deref，Box&lt;Chessboard&gt;的用法基本上和普通Chessboard的用法一样\n\n\n\n\n\n\n\ncrate\n\n每个crate都是既完整又内聚的单元\n包含单个库或可执行程序的所有源代码\n\ncrate是关于项目间代码共享的，而模块是关于项目内代码组织的\n\n它们(crate与module)扮演着Rust命名空间的角色，是构成Rust程序或库的函数、类型、常量等的容器\n\n函数标记为pub(crate)\n\n那么就意味着它可以再这个crate的任何地方使用\n但不会作为外部接口的一部分公开\n\n预导入(prelude)\n\n它们通过收集几乎所有用户都需要的常用导入，减少了样板代码的编写\n把一个模块命名为prelude只是一种约定，旨在告诉用户应该使用*导入它\n\n模块\n\n目录可以作为一个模块，目录名为模块名\n\n目录中包含mod.rs,表示是一个模块，类似Python语言的__init__.py\n\n文件可以作为一个模块，文件名为模块名\n自定义文件中的模块\n\n使用mod关键字\n\n::运算符用于访问模块中的各项特型\n关键字super和crate在路径中有着特殊的含义\n\nsuper指的是父模块\ncrate指的是当前模块所在的crate\n\nas关键字可以给导入的内容重命名\n绝对路径\n\n以::开头，总会引用外部crate\n\nsrc/lib.rs中代码构成了库的根模块\n\n\n\n\n\n\nRust有三种结构体类型\n\n具名字段型结构体\n元组型结构体\n单元型结构体\n\n具名字段型结构体\n\nRust中的约定是\n\n所有类型(包括结构体)的名称都将每个单词的第一个字母大写，称为大驼峰式\n字段和方法是小写的，单词之间用下划线分隔，称为蛇形格式\n\n结构体默认情况下是私有的\n\n仅在声明它们的模块及其子模块中可见\n即使一个结构体声明为pub，它的字段也可以是私有的\n其它模块可以使用此结构体及其任何公共的关联函数，但不能按名称访问私有字段或使用结构体表达式创建新值\n\n\n用impl定义方法\n\nimpl块只是fn定义的集合，每个定义都会成为块顶部命名的结构体类型上的一个方法\n在impl块中定义的函数称为关联函数，因为它们是与特定类型相关联的\nRust会将调用关联函数的结构体值作为第一个参数传给方法\n\n该参数必须具有特殊名称self\n由于self的类型显然就是在impl块顶部命名的类型或对该类型的引用\nself的不同形式\n\nself\n&self\n&mut self\n\n\n\n以Box、Rc或Arc形式传入self\n\n方法的self参数也可以是Box&lt;Self&gt;类型，Rc&lt;Self&gt;类型或Arc&lt;Self&gt;类型\nRust会自动从Box、Rc、Arc等指针类型中借入引用\n\n因此&self和&mut self几乎总是方法签名里的正确选择\n\n\n类型关联函数\n\nimpl块还可以定义根本不以self参数的函数\n这些函数仍然是关联函数，因为它们在impl块中\n但它们不是方法，因为它们不接受self参数\n为了将它们与方法区分开来，我们称其为类型关联函数\n\n泛型结构体\n\nRust结构体可以是泛型的\n\n在泛型结构体定义中，尖括号(&lt;&gt;)中的类型名称叫作类型参数\nSelf参数定义为我们要为其添加方法的任意类型。\n调用关联函数时，使用::&lt;&gt;(比目鱼)表示法显式地提供类型参数\n\n\n带生命周期参数的泛型结构体\n\n如果结构体类型包括引用，则必须为这些引用的生命周期命名\n\n带常量参数的泛型结构体\n\n常量泛型参数可以是任意整数类型、char或bool\n不允许使用浮点数、枚举和其他类型\n如果结构体还接受其他种类的泛型参数\n\n则生命周期参数必须排在第一位，然后是类型，接下来是任何const值\n\n\n内部可变性\n\n我们需要一个不可变值中的一丁点儿可变数据，称为内部可变性\nCell&lt;T&gt;是一个包含类型T的单个私有值的结构体\nCell唯一的特殊之处在，即使你对Cell本身没有mut访问权限，也可以获取和设置这个私有字段\nCell只是改变不变性规则的一种安全方式\n\n一丝不多，一毫不少\nCell不允许在共享值上调用mut方法\n.get()方法会返回Cell中值的副本，因此它仅在T实现了Copy特型时才有效\n\nCell很容易使用\n\n虽然不得不调用.get()和.set()或.borrow()和.borrow_mut()略显尴尬\n但这就是我们为违反规则而付出的代价\n\nCell不是线程安全的\n与Cell不用，RefCell支持借用对其T值的引用\n\n\n\n\n\n\nRust模式有点像针对所有数据的正则表达式\n枚举可以是泛型的，如Option&lt;T&gt;,Result&lt;T&gt;\n只能用一种安全的方式来访问枚举中的数据，即使用模式\nmatch表达式中，模式就是出现在=&gt;符号前面的部分\n表达式会生成值，模式会消耗值\n模式匹配可以和枚举协同工作，甚至可以测试它们包含的数据，这让match成了C的switch语句的强大而灵活的替代品\nmatch也可用来匹配其他类型\n\n字面量、变量、通配符等\n字面量也可以用作模式，包括布尔值、字符，甚至字符串\n不关心匹配的值，那么可以用单个下划线_作为模式，这就是通配符模式\n\n元组型模式匹配元组\n结构体型模式使用花括号，就像结构体表达式一样\n数组型模式与切片模式\n\n切片模式不仅匹配值，还匹配长度\n\n引用型模式\n\nref模式会借用己匹配值的一部分\n&模式会匹配引用`\n匹配不可复制的值会移动该值\n\n\n\n\n\n\nRust通过两个相关联的特性来支持多态\n\n特型和泛型\n\n特型\n\n是Rust体系中的接口或抽象基类\n是一种语言特性，我们可以说某类型支持或不支持某个特型\n大多数情况下，特型代表着一种能力，即一个类型能做什么\n特型本身必须在作用域内\n\nClone和Iterator的各个方法没有导入就能工作，因为默认它们始终在作用域中，是标准库一部分\n预导入主要就是一些精心挑选的特型\n\n\n泛型\n\n是Rust中多态的另一种形式\n\n界限\n\n对类型T可能的类型范围做了限制\n\n泛型和特型的紧密相关\n\n泛型函数会在限界中使用特型来阐明它能针对哪些类型的参数进行调用\n\n\n\n为什么向类型添加特型不需要额外的内存，以及如何在不需要虚方法调用开销的情况下使用特型\n特型对象\n\n在Rust中使用特型编写多态代码有两种方式：\n\n特型对象\n泛型\n\n对特型类型的引用叫作特型对象\nRust通常无法在编译期间知道引用目标的类型，因此特性对象要包含一些关于引用目标类型的额外信息\n特型对象的内存布局\n\n特型对象是一个胖指针\n由指向值的指针和指向表示该值类型的虚表的指针组成\n在Rust中，虚表只会在编译期生成一次，并由同一类型的所有对象共享\n当调用特型对象的方法时，该语言会自动使用虚表来确定调用哪个实现\n在C++中，虚表指针或vptr是作为结构体的一部分存储，而Rust是胖指针方案\nRust中，结构体本身只包含自己的字段\n\n这样一来，每个结构体就可以实现几十个特型而不必包含几十个vptr了\n\nRust在需要时会自动将普通引用转换为特型对象\n创建特型对象的唯一方法\n\n&mut dyn train_name\n&mut dyn Write和Box&lt;dyn Write&gt;也是一个胖指针，包含写入器本身的地址和虚表的地址\n\n\n\n特型对象还是泛型代码的选择相当微妙\n\n由于这两个特性都基于特型\n当需要一些混合类型值的集合时，特型对象是正确的选择\n\n与特型对象相比，泛型具有三个重要优势\n\n第一个优势是速度，没有dyn则不会有动态派发，没有运行期开销\n第二个优势在于并不是每个特性都能支持特型对象\n第三个优势是它很容易同时指定具有多个特型和泛型参数限界，特型对象不能这样\n\n定义与实现特型\n\n定义特型很简单，给它一个名字并列出特型方法的类型签名即可\n要实现特型，请使用语法impl TraitName for Type\n特型的impl代码中定义一切都必须是真正属于此特型的\n自定义函数不能放在特型的impl代码中，只能包含在单独的impl块中\n特型的impl代码中的一切都必须是真正属于此特型\n特型中有未实现的函数，也有已实现的函数\n\n特型中的Self\n\n特型可以用关键字Self作为类型\n使用了Self类型的特型与特型对象不兼容\n特型对象实际上是为最简单的特型类型而设计的\n特型的高级特性很有用，但它们不能与特型对象共存\n\n因为一旦有了特型对象，就会失去Rust对你的程序进行类型检查时所必须的类型信息\n\n\nimpl Trait\n\n是一种静态派发形式\nRust不允许特型方法使用impl Trait作为返回值\n只有最简单的泛型函数中才能把impl Trait参数用作类型，参数的类型之间不能存在关系\n\n类型限界的另一个优点\n\n当遇到编译期错误时，至少编译期可以告诉你问题出在哪里\n限界就这么写在代码和文档中，你可以查看Rust中泛型函数的签名\n并准确了解它能接受的参数类型\n而使用模版则做不到这些\n\n以特型为基础\n\n特型和泛型在所有这些主题中都扮演着核心角色"
  },
  {
    "objectID": "posts/candle_intro/index.html",
    "href": "posts/candle_intro/index.html",
    "title": "Rust机器学习框架-HuggingFace Candle",
    "section": "",
    "text": "Candle是Rust的极简ML框架，重点关注性能，包括GPU支持和易用性。\n\n\n\nCandle项目包括一些crates,如下：\n\ncandle-book: candle相关的文档\ncandle-core: 核心功能库，核心操作，设备，Tensor结构定义等。\ncandle-nn: 神经网络，构建真实模型的工具\ncandle-examples: 在实际环境中使用库的示例\ncandle-datasets: 数据集和数据加载\ncandle-transformers: Transformer相关实现工具\ncandle-flash-attn: Flash Attention v2实现\ncandle-kernels: CUDA加速实现\ncandle-pyo3: Rust提供的Python接口\ncandle-wasm-examples: Rust WASM示例\n\n其它有用的库：\n\ncandle-lora: 提供了符合官方peft实现的LoRA实现\n\n\n\n\n\n语法简单(看起来像PyTorch)\n\n支持模型训练\n支持用于自定义操作运算\n\n后端\n\n优化的CPU后端，具有针对x86的可选MKL支持和针对Mac的Accelerate支持\nCUDA后端可以再GPU上高效运行，通过NCCL运行多GPU分配\nWASM支持，在浏览器中运行模型\n\n包含的模型\n\n语言模型\n\nLLaMA v1 and v2\nFaIcon\nStarCoder\nPhi v1.5\nT5\nBert\n\nWhisper(多语言支持)\nStable Diffusion v1.5, v2.1, XL v1.0\nWurstchen v2\nComputer Vision Models\n\nDINOv2\nEfficientNet\nyolo-v3\nyolo-v8\nSegmeng-Anything(SAM)\n\n\n文件格式\n\n加载模型支持的格式如下:\n\nsafetensors\nnpz\nggml\nPyTorch files\n\n\n无服务部署\n\n小型且快速的部署\n\n使用llama.cpp量化类型的量化支持\n\n\n\n\n\n创建张量\nTensor::new(&[[1f32, 2.], [3., 4.]], &Device::Cpu)?\nTensor::zeros((2, 2), DType::F32, &Device::Cpu)?\n张量索引\ntensor.i((.., ..4))?\n张量重塑\ntensor.reshape((2, 2))?\n张量矩阵乘法\na.matmul(&b)?\n张量数据移动到特定设备\ntensor.to_device(&Device::new_cuda(0)?)?\n更改张量数据类型\ntensor.to_dtype(&Device::F16)?\n张量算术运算\n&a + &b\n保存模型\ncandle::safetensors::save(&HashMap::from([(\"A\", A)]), \"model.safetensors\")?\n加载模型\ncandle::safetensors::load(\"model.safetensors\", &device)"
  },
  {
    "objectID": "posts/candle_intro/index.html#简介",
    "href": "posts/candle_intro/index.html#简介",
    "title": "Rust机器学习框架-HuggingFace Candle",
    "section": "",
    "text": "Candle是Rust的极简ML框架，重点关注性能，包括GPU支持和易用性。"
  },
  {
    "objectID": "posts/candle_intro/index.html#模块",
    "href": "posts/candle_intro/index.html#模块",
    "title": "Rust机器学习框架-HuggingFace Candle",
    "section": "",
    "text": "Candle项目包括一些crates,如下：\n\ncandle-book: candle相关的文档\ncandle-core: 核心功能库，核心操作，设备，Tensor结构定义等。\ncandle-nn: 神经网络，构建真实模型的工具\ncandle-examples: 在实际环境中使用库的示例\ncandle-datasets: 数据集和数据加载\ncandle-transformers: Transformer相关实现工具\ncandle-flash-attn: Flash Attention v2实现\ncandle-kernels: CUDA加速实现\ncandle-pyo3: Rust提供的Python接口\ncandle-wasm-examples: Rust WASM示例\n\n其它有用的库：\n\ncandle-lora: 提供了符合官方peft实现的LoRA实现"
  },
  {
    "objectID": "posts/candle_intro/index.html#特点",
    "href": "posts/candle_intro/index.html#特点",
    "title": "Rust机器学习框架-HuggingFace Candle",
    "section": "",
    "text": "语法简单(看起来像PyTorch)\n\n支持模型训练\n支持用于自定义操作运算\n\n后端\n\n优化的CPU后端，具有针对x86的可选MKL支持和针对Mac的Accelerate支持\nCUDA后端可以再GPU上高效运行，通过NCCL运行多GPU分配\nWASM支持，在浏览器中运行模型\n\n包含的模型\n\n语言模型\n\nLLaMA v1 and v2\nFaIcon\nStarCoder\nPhi v1.5\nT5\nBert\n\nWhisper(多语言支持)\nStable Diffusion v1.5, v2.1, XL v1.0\nWurstchen v2\nComputer Vision Models\n\nDINOv2\nEfficientNet\nyolo-v3\nyolo-v8\nSegmeng-Anything(SAM)\n\n\n文件格式\n\n加载模型支持的格式如下:\n\nsafetensors\nnpz\nggml\nPyTorch files\n\n\n无服务部署\n\n小型且快速的部署\n\n使用llama.cpp量化类型的量化支持"
  },
  {
    "objectID": "posts/candle_intro/index.html#基本用法介绍",
    "href": "posts/candle_intro/index.html#基本用法介绍",
    "title": "Rust机器学习框架-HuggingFace Candle",
    "section": "",
    "text": "创建张量\nTensor::new(&[[1f32, 2.], [3., 4.]], &Device::Cpu)?\nTensor::zeros((2, 2), DType::F32, &Device::Cpu)?\n张量索引\ntensor.i((.., ..4))?\n张量重塑\ntensor.reshape((2, 2))?\n张量矩阵乘法\na.matmul(&b)?\n张量数据移动到特定设备\ntensor.to_device(&Device::new_cuda(0)?)?\n更改张量数据类型\ntensor.to_dtype(&Device::F16)?\n张量算术运算\n&a + &b\n保存模型\ncandle::safetensors::save(&HashMap::from([(\"A\", A)]), \"model.safetensors\")?\n加载模型\ncandle::safetensors::load(\"model.safetensors\", &device)"
  },
  {
    "objectID": "posts/rust_toolchain/index.html",
    "href": "posts/rust_toolchain/index.html",
    "title": "Rust Toolchain常用功能介绍",
    "section": "",
    "text": "rustup常用命令\nrustup是Rust语言的一个安装器。\n可以管理Rust Toolchain以及rustup等工具链组件\n\n查看当前编译器信息\n\nrustup show\n\n更新Rust Toolchain\n\nrust update\n\n检查更新Rust Toolchain和rustup\n\nrustup check\n\n设置默认工具链\n\nrustup default -h\n\n管理component\n\n\n安装组件\n\nrust component add &lt;component_name&gt;\n\n删除组件\n\nrust component remove &lt;component_name&gt;\n\n列出所有可用组件\n\nrust component list\n\n列出以安装组件\n\nrust component list --installed\n\n\nClippy\n一系列lints，用于捕获常见错误并改进Rust代码。\n\n安装\nrustup update\nrustup component add clippy\n\n\n运行Clippy\ncargo clippy\n或者\ncargo check\n\n\n自动应用Clippy建议\ncargo clippy --fix\n\n\n配置文件\n\nclippy.toml\n.clippy.toml\n\n\n\n\nRustfmt\nRust代码格式化工具\n\n安装\nrustup component add rustfmt\n\n\n运行\ncargo fmt\n\n\n配置文件\n\nrustfmt.toml\n.rustfmt.toml\n\n\n\n\nRust-Analyzer\nrust-analyzer是Rust编程语言的语言服务器协议的实现。"
  },
  {
    "objectID": "posts/started/index.html",
    "href": "posts/started/index.html",
    "title": "你好, Quarto",
    "section": "",
    "text": "今天把博客从Hugo迁移到Quarto。在这一天也有了自己人生未来的新计划。\n                             | |\n__  ___   _  __ _ _ __    ___| |__  _   _\n\\ \\/ / | | |/ _` | '_ \\  / __| '_ \\| | | |\n &gt;  &lt;| |_| | (_| | | | | \\__ \\ | | | |_| |\n/_/\\_\\\\__,_|\\__,_|_| |_| |___/_| |_|\\__,_|\n__   __    __   ___\n\\ \\ / /    \\ \\ / (_)\n \\ V /___   \\ V / _ _ __   __ _\n  \\ // _ \\   \\ / | | '_ \\ / _` |\n  | |  __/   | | | | | | | (_| |\n  \\_/\\___|   \\_/ |_|_| |_|\\__, |\n                           __/ |\n                          |___/"
  },
  {
    "objectID": "posts/started/index.html#新的开始",
    "href": "posts/started/index.html#新的开始",
    "title": "你好, Quarto",
    "section": "",
    "text": "今天把博客从Hugo迁移到Quarto。在这一天也有了自己人生未来的新计划。\n                             | |\n__  ___   _  __ _ _ __    ___| |__  _   _\n\\ \\/ / | | |/ _` | '_ \\  / __| '_ \\| | | |\n &gt;  &lt;| |_| | (_| | | | | \\__ \\ | | | |_| |\n/_/\\_\\\\__,_|\\__,_|_| |_| |___/_| |_|\\__,_|\n__   __    __   ___\n\\ \\ / /    \\ \\ / (_)\n \\ V /___   \\ V / _ _ __   __ _\n  \\ // _ \\   \\ / | | '_ \\ / _` |\n  | |  __/   | | | | | | | (_| |\n  \\_/\\___|   \\_/ |_|_| |_|\\__, |\n                           __/ |\n                          |___/"
  },
  {
    "objectID": "posts/clip/index.html",
    "href": "posts/clip/index.html",
    "title": "CLIP",
    "section": "",
    "text": "由图像分类模型生成的现成特征已被用于图像检索等其他任务中。\n但是，这些特征的通用性不强，\n因为分类模型是为识别一组固定的类别而训练的。\n要在这组类别中添加任何新类别，\n都需要为这一新类别收集额外的标注图像，\n然后重新训练模型。\n这是一个耗时且昂贵的过程。\n能否利用自监督学习技术来解决这一问题？\n能否利用图像说明来生成更好的图像表征并避免标注成本？ 也就是说，能否使用自然语言作为监督来学习视觉感知？\n\n\n\n作者提出了一项预训练任务(CLIP = Contrastive Language Pre-training),\n\n即预测哪张图片配哪句标题，以便从头开始学习SOTA图像表征。\n\n为此，他们创建了一个从互联网上收集的包含4亿个(图片、文本)配对的数据集:\n\n这种预先训练好的模型可以不费吹灰之力地应用到大多数任务中\n而且不需要任何特定数据集的训练，就能与完全有监督的基线模型相媲美。\n\n\n\n\nCLIP从监督图像描述(supervised image captioning):\n\n每张图片(image)都有相应的标题(caption),\n用来训练一个模型，\n预测相应图片标题中的准确词语。\n\n这是一项艰巨的任务，因为一幅图像可以有多种不同的描述方式，但仍能表达相同的含义。\n\n\n\n对比预训练:\n\n考虑一批N个图像(images)及其相应的N个标题(captions)。\n有了这些，我们可以再批次中创建NxN可能的(图像、文本)配对。\n现在，任务是预测批次中的N个真实对\n\n为此，CLIP通过联合训练:\n\n图像编码器和文本编码器\n来学习多模态嵌入空间。\n图像编码器产生特征向量I;\n类似地，文本编码器产生一个特征向量T;\n\n\n对于N个实数对，我们希望最大化I和T之间的余弦相似度\n对于\\(N^2-N\\)不正确的配对，我们希望最小化I和T之间的余弦相似度\n\n\n\n\n|----------|      |---------------|      |----------|\n|  Image   | ---&gt; | Image Encoder | ---&gt; | I Vector | ---------------|\n|----------|      |---------------|      |----------|                V\n                                                             |---------------|\n                                                             |               |\n                                                             |               |\n                                                             |               |\n|----------|      |---------------|      |----------|        |               |\n|   Text   | ---&gt; | Text Encoder  | ---&gt; | T Vector |------&gt; |               |\n|----------|      |---------------|      |----------|        |---------------|\n\n\n\n图片来源于论文\n\n\n\n\n\n考虑图像分类任务， 预测时，对于单张图像，图像编码器将生成一个特征向量\\(I_1\\) 为了识别图像类别， 文本编码器会嵌入目标数据集的类别名称， 生成N个特征向量\\(T_1,T_2,......\\),以此类推。 N表示目标数据集中的类别数\nCreate dataset classifier from label text\n|-------|\n| plane |\n| car   |        |-----------------------|                   |--------------|\n| dog   | -----&gt; | A photo of a {object} | ----------------&gt; | Text Encoder |\n| bird  |        |-----------------------|                   |--------------|\n| cat   |                                                            |\n|-------|                                                            |\n                                                                     |\nUse for zero-shot prediction                                         V\n|-------|        |---------------|        |-----|     |-----|-----|-----|-----|-----|\n| Image | -----&gt; | Image Encoder | -----&gt; | I_1 |     | T_1 | T_2 | T_3 | ... | T_N |\n|-------|        |---------------|        |-----|     |-----|-----|-----|-----|-----|\n                                             |                                   |\n                                             |        .*                         |  \n                                             |-----------------------------------|\n                                                                 |\n                                                                 V    \n                                          |--------|--------|--------|-----|--------|\n                                          |I_1.*T_1|I_1.*T_2|I_1.*T_3| ... |I_1.*T_N|\n                                          |--------|--------|--------|-----|--------|\n                                                                 |\n                                                                 V\n                                                        |--------------------|\n                                                        | A photo of a `dog` |\n                                                        |--------------------|\n\n\n\n图片来源于论文\n\n\n\n\n\n\n对于图像编码器，作者评估了两种不同的架构： - ResNet-50 - ViT\n\n\n他们使用了改进的ResNet-D架构,\n并进行了抗锯齿矩阵-2模糊池化(anti-aliased rect-2 blur pooling)处理。\n他们还用Transformer-style attention pooling mechanism替换了global average pooling layer\n\n\n\n作者在Transformer之前\n组合patch和position embedding进行了额外的归一化处理( use an additional layer normalization to the combined patch and position embedding)，\n并使用了略有不同的初始化方案。\n\n\n\n使用本文中描述的具有:\n\n6300万个参数(12层 512-wide)\n8个注意力头的Transformer\n\n\n\n\n\n作者训练的模型包括：\n\n5个ResNet\n\nResNet-50\nResNet-101\n3个EfficientNet风格的ResNet模型\n\n3个ViT\n\nViT-B/32\nViT-B/16\nViT-L/14\n\nThe models are trained：\n\n32 epochs\nusing Adam optimizer with decoupled weight decay regularization\ndecay the learning rate using a cosine schedule\nused a very large minibatch size of 32,768\n\n\n\n\n\n图像分类数据集标注了与类名相对应的label IDs\n由于CLIP模式在文本为一个完整句子的情况下进行训练的，\n因此作者发现使用提示模版(prompt template)A photo of a {label}，\n是与图像相关联的文本的良好默认设置。\n我们可以看到在36各分类数据集中，使用提示工程的分类准确率提高了5个百分点。\n\n\n\n图片来源于论文\n\n\n\n\n\n在27个数据集中的16个数据集上:\n\nzero-shot CLIP分类器的表现优于基于ResNet-50特征的监督线性分类器。\n不过，在大多数数据集上，CLIP的性能仍低于最新水平\n\n\n\n\n图片来源于论文\n\n\n\n\n\n\nCLIP以下任务上性能不佳\n\ncounting object in an image\nfinding the distance to the nearest object object in an image\n\n在MNIST等分布外数据集上的表现非常差\n\n在数字OCR上性能很好\n但在识别MNIST手写数字方面却不好(准确率88%)\n\n使用CLIP进行few-shot learning会导致性能不佳\n\nfrom zero-shot to few-shot learning时，性能会出现反直觉的下降\n\n由于CLIP是根据互联网上查询的文本图像对进行训练的\n\n因此它将会学习许多社会偏见\n\n\n\n\n\nNotes on CLIP: Connecting Text and Images\nCLIP paper"
  },
  {
    "objectID": "posts/clip/index.html#监督学习的局限性",
    "href": "posts/clip/index.html#监督学习的局限性",
    "title": "CLIP",
    "section": "",
    "text": "由图像分类模型生成的现成特征已被用于图像检索等其他任务中。\n但是，这些特征的通用性不强，\n因为分类模型是为识别一组固定的类别而训练的。\n要在这组类别中添加任何新类别，\n都需要为这一新类别收集额外的标注图像，\n然后重新训练模型。\n这是一个耗时且昂贵的过程。\n能否利用自监督学习技术来解决这一问题？\n能否利用图像说明来生成更好的图像表征并避免标注成本？ 也就是说，能否使用自然语言作为监督来学习视觉感知？"
  },
  {
    "objectID": "posts/clip/index.html#主要贡献",
    "href": "posts/clip/index.html#主要贡献",
    "title": "CLIP",
    "section": "",
    "text": "作者提出了一项预训练任务(CLIP = Contrastive Language Pre-training),\n\n即预测哪张图片配哪句标题，以便从头开始学习SOTA图像表征。\n\n为此，他们创建了一个从互联网上收集的包含4亿个(图片、文本)配对的数据集:\n\n这种预先训练好的模型可以不费吹灰之力地应用到大多数任务中\n而且不需要任何特定数据集的训练，就能与完全有监督的基线模型相媲美。"
  },
  {
    "objectID": "posts/clip/index.html#背景",
    "href": "posts/clip/index.html#背景",
    "title": "CLIP",
    "section": "",
    "text": "CLIP从监督图像描述(supervised image captioning):\n\n每张图片(image)都有相应的标题(caption),\n用来训练一个模型，\n预测相应图片标题中的准确词语。\n\n这是一项艰巨的任务，因为一幅图像可以有多种不同的描述方式，但仍能表达相同的含义。"
  },
  {
    "objectID": "posts/clip/index.html#contrastive-pre-training对比预训练",
    "href": "posts/clip/index.html#contrastive-pre-training对比预训练",
    "title": "CLIP",
    "section": "",
    "text": "对比预训练:\n\n考虑一批N个图像(images)及其相应的N个标题(captions)。\n有了这些，我们可以再批次中创建NxN可能的(图像、文本)配对。\n现在，任务是预测批次中的N个真实对\n\n为此，CLIP通过联合训练:\n\n图像编码器和文本编码器\n来学习多模态嵌入空间。\n图像编码器产生特征向量I;\n类似地，文本编码器产生一个特征向量T;\n\n\n对于N个实数对，我们希望最大化I和T之间的余弦相似度\n对于\\(N^2-N\\)不正确的配对，我们希望最小化I和T之间的余弦相似度\n\n\n\n\n|----------|      |---------------|      |----------|\n|  Image   | ---&gt; | Image Encoder | ---&gt; | I Vector | ---------------|\n|----------|      |---------------|      |----------|                V\n                                                             |---------------|\n                                                             |               |\n                                                             |               |\n                                                             |               |\n|----------|      |---------------|      |----------|        |               |\n|   Text   | ---&gt; | Text Encoder  | ---&gt; | T Vector |------&gt; |               |\n|----------|      |---------------|      |----------|        |---------------|\n\n\n\n图片来源于论文\n\n\n\n\n\n考虑图像分类任务， 预测时，对于单张图像，图像编码器将生成一个特征向量\\(I_1\\) 为了识别图像类别， 文本编码器会嵌入目标数据集的类别名称， 生成N个特征向量\\(T_1,T_2,......\\),以此类推。 N表示目标数据集中的类别数\nCreate dataset classifier from label text\n|-------|\n| plane |\n| car   |        |-----------------------|                   |--------------|\n| dog   | -----&gt; | A photo of a {object} | ----------------&gt; | Text Encoder |\n| bird  |        |-----------------------|                   |--------------|\n| cat   |                                                            |\n|-------|                                                            |\n                                                                     |\nUse for zero-shot prediction                                         V\n|-------|        |---------------|        |-----|     |-----|-----|-----|-----|-----|\n| Image | -----&gt; | Image Encoder | -----&gt; | I_1 |     | T_1 | T_2 | T_3 | ... | T_N |\n|-------|        |---------------|        |-----|     |-----|-----|-----|-----|-----|\n                                             |                                   |\n                                             |        .*                         |  \n                                             |-----------------------------------|\n                                                                 |\n                                                                 V    \n                                          |--------|--------|--------|-----|--------|\n                                          |I_1.*T_1|I_1.*T_2|I_1.*T_3| ... |I_1.*T_N|\n                                          |--------|--------|--------|-----|--------|\n                                                                 |\n                                                                 V\n                                                        |--------------------|\n                                                        | A photo of a `dog` |\n                                                        |--------------------|\n\n\n\n图片来源于论文"
  },
  {
    "objectID": "posts/clip/index.html#模型细节",
    "href": "posts/clip/index.html#模型细节",
    "title": "CLIP",
    "section": "",
    "text": "对于图像编码器，作者评估了两种不同的架构： - ResNet-50 - ViT\n\n\n他们使用了改进的ResNet-D架构,\n并进行了抗锯齿矩阵-2模糊池化(anti-aliased rect-2 blur pooling)处理。\n他们还用Transformer-style attention pooling mechanism替换了global average pooling layer\n\n\n\n作者在Transformer之前\n组合patch和position embedding进行了额外的归一化处理( use an additional layer normalization to the combined patch and position embedding)，\n并使用了略有不同的初始化方案。\n\n\n\n使用本文中描述的具有:\n\n6300万个参数(12层 512-wide)\n8个注意力头的Transformer"
  },
  {
    "objectID": "posts/clip/index.html#训练",
    "href": "posts/clip/index.html#训练",
    "title": "CLIP",
    "section": "",
    "text": "作者训练的模型包括：\n\n5个ResNet\n\nResNet-50\nResNet-101\n3个EfficientNet风格的ResNet模型\n\n3个ViT\n\nViT-B/32\nViT-B/16\nViT-L/14\n\nThe models are trained：\n\n32 epochs\nusing Adam optimizer with decoupled weight decay regularization\ndecay the learning rate using a cosine schedule\nused a very large minibatch size of 32,768"
  },
  {
    "objectID": "posts/clip/index.html#提示工程的效果effect-of-prompt-engineering",
    "href": "posts/clip/index.html#提示工程的效果effect-of-prompt-engineering",
    "title": "CLIP",
    "section": "",
    "text": "图像分类数据集标注了与类名相对应的label IDs\n由于CLIP模式在文本为一个完整句子的情况下进行训练的，\n因此作者发现使用提示模版(prompt template)A photo of a {label}，\n是与图像相关联的文本的良好默认设置。\n我们可以看到在36各分类数据集中，使用提示工程的分类准确率提高了5个百分点。\n\n\n\n图片来源于论文"
  },
  {
    "objectID": "posts/clip/index.html#zero-shot-clip-vs.-linear-probe",
    "href": "posts/clip/index.html#zero-shot-clip-vs.-linear-probe",
    "title": "CLIP",
    "section": "",
    "text": "在27个数据集中的16个数据集上:\n\nzero-shot CLIP分类器的表现优于基于ResNet-50特征的监督线性分类器。\n不过，在大多数数据集上，CLIP的性能仍低于最新水平\n\n\n\n\n图片来源于论文"
  },
  {
    "objectID": "posts/clip/index.html#limitations局限性",
    "href": "posts/clip/index.html#limitations局限性",
    "title": "CLIP",
    "section": "",
    "text": "CLIP以下任务上性能不佳\n\ncounting object in an image\nfinding the distance to the nearest object object in an image\n\n在MNIST等分布外数据集上的表现非常差\n\n在数字OCR上性能很好\n但在识别MNIST手写数字方面却不好(准确率88%)\n\n使用CLIP进行few-shot learning会导致性能不佳\n\nfrom zero-shot to few-shot learning时，性能会出现反直觉的下降\n\n由于CLIP是根据互联网上查询的文本图像对进行训练的\n\n因此它将会学习许多社会偏见"
  },
  {
    "objectID": "posts/clip/index.html#references",
    "href": "posts/clip/index.html#references",
    "title": "CLIP",
    "section": "",
    "text": "Notes on CLIP: Connecting Text and Images\nCLIP paper"
  },
  {
    "objectID": "posts/kubernetes_the_hard_way/index.html",
    "href": "posts/kubernetes_the_hard_way/index.html",
    "title": "Kubernetes the hard way",
    "section": "",
    "text": "服务器说明\n\nKubernets Version\n\n\nv1.22.15\n\n\n节点要求\n\n\n节点数 &gt;= 3台\nCPUs &gt;= 2\nMemory &gt;= 2G\n\n\n修改时区 有的系统时区不匹配，需要修改\n\ntimedatectl set-timezone Asia/Shanghai\n\n环境说明\n\n\n\n\n系统类型\nIP地址\n节点角色\nCPU\nMemory\nHostname\n\n\n\n\nCentOS-7.9\n192.168.200.11\nmaster\n&gt;=2\n&gt;=2G\ncluster1\n\n\nCentOS-7.9\n192.168.200.22\nmaster,worker\n&gt;=2\n&gt;=2G\ncuster2\n\n\nCentOS-7.9\n192.168.200.33\nworker\n&gt;=2\n&gt;=2G\ncluster3\n\n\n\n\n使用Vagrant搭建虚拟机节点\n\n\nVagrant: latest\nVirtualBox: 7.0\nvagrant-vbguest: 0.21 (挂载host和guest同步目录)\n\nvagrant plugin install vagrant-vbguest --plugin-version 0.21\nVagrantfile配置文件如下:\n# -*- mode: ruby -*-\n# vi: set ft=ruby :\n\nnodes = [\n  {\n    :name =&gt; \"cluster1\",\n    :eth1 =&gt; \"192.168.200.11\",\n    :mem =&gt; \"4096\",\n    :cpu =&gt; \"2\"\n  },\n  {\n    :name =&gt; \"cluster2\",\n    :eth1 =&gt; \"192.168.200.22\",\n    :mem =&gt; \"4096\",\n    :cpu =&gt; \"2\"\n  },\n  {\n    :name =&gt; \"cluster3\",\n    :eth1 =&gt; \"192.168.200.33\",\n    :mem =&gt; \"4096\",\n    :cpu =&gt; \"2\"\n  },\n]\n\n\nVagrant.configure(\"2\") do |config|\n  # Every Vagrant development environment requires a box.\n  config.vm.box = \"centos/7\"\n\n  nodes.each do |opts|\n    config.vm.define opts[:name] do |config|\n      config.vm.hostname = opts[:name]\n\n      config.vm.provider \"virtualbox\" do |v|\n        v.customize [\"modifyvm\", :id, \"--memory\", opts[:mem]]\n        v.customize [\"modifyvm\", :id, \"--cpus\", opts[:cpu]]\n      end\n\n      #config.ssh.username = \"root\"\n      #config.ssh.private_key_path = \"/Users/jinpeng.d/.ssh/id_rsa\"\n      config.vm.synced_folder \"../share\", \"/vagrant_data\"\n\n      config.vm.network :public_network, ip: opts[:eth1]\n      config.vm.synced_folder \"../share\", \"/vagrant_data\"\n\n    end\n  end\nend\n\n\n系统设置(所有节点)\n\n所有操作需要root权限\nhostname (/etc/hosts)\n安装依赖包\n\nyum update -y\nyum install -y socat conntrack ipvsadm ipset jq sysstat curl iptables libseccomp yum-utils\n\n关闭防火墙,selinux, swap,重置 iptables\n\n# 1. 关闭selinux\nsetenforce 0\nsed -i '/SELINUX/s/enforcing/disabled/' /etc/selinux/config\n# 2. 关闭防火墙\nsystemctl stop firewalld && systemctl disable firewalld\n\n# 3. 设置ipttables规则\niptables -F && iptables -X && iptables -F -t nat && iptables -X -t nat && iptables -P FORWARD ACCEPT\n\n# 4. 关闭swap\nvi /etc/fstab\n# 永久禁用注释掉swap\n#/swapfile none swap defaults 0 0\n# 临时禁用\nswapoff -a\n# 这里两者都用，临时修改可以即时生效，不用重启，永久禁用防止重启后不生效\n\n# 5. 关闭dnsmasq(否则无法解析域名)\nservice dnsmasq stop && systemctl disable dnsmasq\n\nkubernetes参数设置\n\ncat &gt; /etc/sysctl.d/kubernetes.conf &lt;&lt;EOF\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nnet.ipv4.ip_nonlocal_bind = 1\nnet.ipv4.ip_forward = 1\nvm.swappiness = 0\nvm.overcommit_memory = 1\nEOF\n\n# 生效文件\nsysctl -p /etc/sysctl.d/kubernetes.conf\n\n配置免密登录 选择其中一个节点，或者一个单独的机器生成ssh公秘钥对，把公钥放在k8s所有节点服务器上\n\n# 生成公秘钥对, 如果没有可用的\nssh-keygen -t rsa\n\n# 查看公钥内容\ncat ~/.ssh/id_rsa.pub\n\n# 每一台节点机器上配置\necho \"&lt;pubkey content&gt;\" &gt;&gt; ~/.ssh/authorized_keys\n\n配置IP映射(每个节点)\n\ncat &gt; /etc/hosts &lt;&lt;EOF\n192.168.200.11 cluster1\n192.168.200.22 cluster2\n192.168.200.33 cluster3\nEOF\n\n下载k8s组件包\n\nexport VERSION=v1.22.15\n\n# 下载master节点组件\nwget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kube-apiserver\nwget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kube-controller-manager\nwget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kube-scheduler\nwget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kubectl\n\n# 下载worker节点组件\nwget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kube-proxy\nwget https://storage.googleapis.com/kubernetes-release/release/${VERSION}/bin/linux/amd64/kubelet\n\n# 下载etcd组件\nwget https://github.com/etcd-io/etcd/releases/download/v3.4.10/etcd-v3.4.10-linux-amd64.tar.gz\ntar -xvf etcd-v3.4.10-linux-amd64.tar.gz\nmv etcd-v3.4.10-linux-amd64/etcd* .\nrm -fr etcd-v3.4.10-linux-amd64*\n\n分发软件包\n\n# 把master相关组件分发到master节点\nMASTERS=(cluster1 cluster2)\nfor instance in ${MASTERS[@]}; do\n  scp kube-apiserver kube-controller-manager kube-scheduler kubectl root@${instance}:/usr/local/bin/\ndone\n\n# 把worker先关组件分发到worker节点\nWORKERS=(cluster2 cluster3)\nfor instance in ${WORKERS[@]}; do\n  scp kubelet kube-proxy root@${instance}:/usr/local/bin/\ndone\n\n# 把etcd组件分发到etcd节点\nETCDS=(cluster1 cluster2 cluster3)\nfor instance in ${ETCDS[@]}; do\n  scp etcd etcdctl root@${instance}:/usr/local/bin/\ndone\n\n\n生成证书\n\n准备工作\n\n\n安装cfssl\nwget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64 -O /usr/local/bin/cfssl\nwget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64 -O /usr/local/bin/cfssljson\nchmod +x /usr/local/bin/cfssl*\nkubernetes集群组件\n\n服务端组件:\n\nkube-apiserver\nkube-controller-manager\nkube-scheduler\nkubectl\ncontainer runtime(containerd)\n\n客户端组件:\n\nkubelet\nkube-proxy\ncontainer runtime(containerd)\n\n\n\n\n生成根证书 根证书是集群所有节点共享的，只要创建一个CA证书，后续创建的所有证书都由它签名。 在可以登录到所有节点的控制台机器上创建pki目录存放证书\n\n\n根证书配置文件创建\ncat &gt; ca-config.json &lt;&lt;EOF\n{\n  \"signing\": {\n    \"default\": {\n      \"expiry\": \"876000h\"\n    },\n    \"profiles\": {\n      \"kubernetes\": {\n        \"usages\": [\"signing\", \"key encipherment\", \"server auth\", \"client auth\"],\n        \"expiry\": \"876000h\"\n      }\n    }\n  }\n}\nEOF\n\ncat &gt; ca-csr.json &lt;&lt;EOF\n{\n  \"CN\": \"Kubernetes\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"US\",\n      \"L\": \"Portland\",\n      \"O\": \"Kubernetes\",\n      \"OU\": \"CA\",\n      \"ST\": \"Oregon\"\n    }\n  ]\n}\nEOF\n生成证书和密钥\n\n生成证书和私钥, ca.pem是证书, ca-key.pem是证书私钥 bash   cfssl gencert -initca ca-csr.json | cfssljson -bare ca 输出文件:\n\nca.pem\nca.csr\nca-key.pem\n\n\nadmin客户端证书\n\n\nadmin客户端证书配置文件\ncat &gt; admin-csr.json &lt;&lt;EOF\n{\n  \"CN\": \"admin\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"ST\": \"BeiJing\",\n      \"L\": \"BeiJing\",\n      \"O\": \"system:masters\",\n      \"OU\": \"seven\"\n    }\n  ]\n}\nEOF\n生成admin客户端证书和私钥(基于根证书和私钥以及证书配置文件)\ncfssl gencert \\\n  -ca=ca.pem \\\n  -ca-key=ca-key.pem \\\n  -config=ca-config.json \\\n  -profile=kubernetes \\\n  admin-csr.json | cfssljson -bare admin\n输出文件:\n\nadmin.csr\nadmin.pem\nadmin-key.pem\n\n\n\nkubelet客户端证书 kubernetes使用一种称为Node Authorizer的专用授权模式来授权kubernetes发出的API请求。 kubelet使用将其标识为system:nodes组中的凭据,其用户名为system: node:nodeName, 接下来给每个Worker节点生成证书。\n\n\n生成kubelet客户端证书配置文件\n\n设置Worker节点列表\n\nWORKERS=(cluster2 cluster3)\nWORKER_IPS=(192.168.200.22 192.168.200.33)\nfor ((i=0;i&lt;${#WORKERS[@]};i++)); do\n  cat &gt; ${WORKERS[$i]}-csr.json &lt;&lt;EOF\n  {\n    \"CN\": \"system:node:${WORKERS[$i]}\",\n    \"key\": {\n      \"algo\": \"rsa\",\n      \"size\": 2048\n    },\n    \"names\": [\n      {\n        \"C\": \"CN\",\n        \"L\": \"Beijing\",\n        \"O\": \"system:nodes\",\n        \"OU\": \"seven\",\n        \"ST\": \"Beijing\"\n      }\n    ]\n  }\nEOF\ndone\n生成kubelet客户端证书和密钥\nfor ((i=0;i&lt;${#WORKERS[@]};i++)); do\n  cfssl gencert \\\n    -ca=ca.pem \\\n    -ca-key=ca-key.pem \\\n    -config=ca-config.json \\\n    -hostname=${WORKERS[$i]},${WORKER_IPS[$i]} \\\n    -profile=kubernetes \\\n    ${WORKERS[$i]}-csr.json | cfssljson -bare ${WORKERS[$i]}\ndone\n输出文件:\n\n{worker-node-name}.csr\n{worker-node-name}.pem\n{worker-node-name}-key.pem\n\n\n\nkube-controller-manager客户端证书\n\n\nkube-controller-manager客户端证书配置文件\n\ncat &gt; kube-controller-manager-csr.json &lt;&lt;EOF\n{\n    \"CN\": \"system:kube-controller-manager\",\n    \"key\": {\n        \"algo\": \"rsa\",\n        \"size\": 2048\n    },\n    \"names\": [\n      {\n        \"C\": \"CN\",\n        \"ST\": \"BeiJing\",\n        \"L\": \"BeiJing\",\n        \"O\": \"system:kube-controller-manager\",\n        \"OU\": \"seven\"\n      }\n    ]\n}\nEOF\n\n生成kube-controller-manager客户端证书\n\ncfssl gencert \\\n-ca=ca.pem \\\n-ca-key=ca-key.pem \\\n-config=ca-config.json \\\n-profile=kubernetes \\\nkube-controller-manager-csr.json | cfssljson -bare kube-controller-manager\n输出文件: + kube-controller-manager.csr + kube-controller-manager.pem + kube-controller-manager-key.pem\n\nkube-proxy客户端证书\n\n\nkube-proxy客户端证书配置文件\ncat &gt; kube-proxy-csr.json &lt;&lt;EOF\n{\n  \"CN\": \"system:kube-proxy\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"ST\": \"BeiJing\",\n      \"L\": \"BeiJing\",\n      \"O\": \"k8s\",\n      \"OU\": \"seven\"\n    }\n  ]\n}\nEOF\n生成kube-proxy客户端证书\ncfssl gencert \\\n-ca=ca.pem \\\n-ca-key=ca-key.pem \\\n-config=ca-config.json \\\n-profile=kubernetes \\\nkube-proxy-csr.json | cfssljson -bare kube-proxy\n输出文件:\n\nkube-proxy.csr\nkube-proxy.pem\nkube-proxy-key.pem\n\n\n\nkube-scheduler客户端证书\n\n\nkube-scheduler客户端证书配置\ncat &gt; kube-scheduler-csr.json &lt;&lt;EOF\n{\n    \"CN\": \"system:kube-scheduler\",\n    \"key\": {\n        \"algo\": \"rsa\",\n        \"size\": 2048\n    },\n    \"names\": [\n      {\n        \"C\": \"CN\",\n        \"ST\": \"BeiJing\",\n        \"L\": \"BeiJing\",\n        \"O\": \"system:kube-scheduler\",\n        \"OU\": \"seven\"\n      }\n    ]\n}\nEOF\n生成kube-scheduler客户端证书\ncfssl gencert \\\n-ca=ca.pem \\\n-ca-key=ca-key.pem \\\n-config=ca-config.json \\\n-profile=kubernetes \\\nkube-scheduler-csr.json | cfssljson -bare kube-scheduler\n输出文件:\n\nkube-scheduler.csr\nkube-scheduler.pem\nkube-scheduler-key.pem\n\n\n\nkube-apiserver服务端证书\n\n\nkube-apiserver服务端证书配置\ncat &gt; kubernetes-csr.json &lt;&lt;EOF\n{\n  \"CN\": \"kubernetes\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"ST\": \"BeiJing\",\n      \"L\": \"BeiJing\",\n      \"O\": \"k8s\",\n      \"OU\": \"seven\"\n    }\n  ]\n}\nEOF\n生成kube-apiserver服务端证书 服务端证书与客户端证书不同:\n\n客户端证书需要通过一个名字或者IP去访问服务端，所以证书需要包含客户端所访问的名字或IP，用以客户端验证\n指定可能作为master的节点服务地址\napiserver的 service ip地址(一般是svc网段的第一个ip)\n所有master内网IP和公网IP，逗号分割，(可以把所有节点写上，防止变换master节点)\n\nKUBERNETES_SVC_IP=\"10.233.0.1\"\nMASTER_IPS=\"192.168.200.11,192.168.200.22,192.168.200.33\"\ncfssl gencert \\\n-ca=ca.pem \\\n-ca-key=ca-key.pem \\\n-config=ca-config.json \\\n-hostname=${KUBERNETES_SVC_IP},${MASTER_IPS},127.0.0.1,kubernetes,kubernetes.default,kubernetes.default.svc,kubernetes.default.svc.cluster,kubernetes.svc.cluster.local \\\n-profile=kubernetes \\\nkubernetes-csr.json | cfssljson -bare kubernetes\n输出文件:\n\nkubernetes.csr\nkubernetes.pem\nkubernetes-key.pem\n\n\n\nService Account证书\n\n\n配置文件\ncat &gt; service-account-csr.json &lt;&lt;EOF\n{\n  \"CN\": \"service-accounts\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"ST\": \"BeiJing\",\n      \"L\": \"BeiJing\",\n      \"O\": \"k8s\",\n      \"OU\": \"seven\"\n    }\n  ]\n}\nEOF\n生成证书\ncfssl gencert \\\n-ca=ca.pem \\\n-ca-key=ca-key.pem \\\n-config=ca-config.json \\\n-profile=kubernetes \\\nservice-account-csr.json | cfssljson -bare service-account\n输出文件:\n\nservice-account.csr\nservice-account.pem\nservice-account-key.pem\n\n\n\nproxy-client证书\n\n\n配置文件\ncat &gt; proxy-client-csr.json &lt;&lt;EOF\n{\n  \"CN\": \"aggregator\",\n  \"key\": {\n    \"algo\": \"rsa\",\n    \"size\": 2048\n  },\n  \"names\": [\n    {\n      \"C\": \"CN\",\n      \"ST\": \"BeiJing\",\n      \"L\": \"BeiJing\",\n      \"O\": \"k8s\",\n      \"OU\": \"seven\"\n    }\n  ]\n}\nEOF\n生成证书\ncfssl gencert \\\n-ca=ca.pem \\\n-ca-key=ca-key.pem \\\n-config=ca-config.json \\\n-profile=kubernetes \\\nproxy-client-csr.json | cfssljson -bare proxy-client\n输出文件:\n\nproxy-client.csr\nproxy-client.pem\nproxy-client-key.pem\n\n\n\n分发客户端，服务端证书\n\n\n分发Worker节点需要的证书和私钥\n\n每个Worker节点证书和密钥\n\nWORKERS=(\"cluster2\" \"cluster3\")\nfor instance in ${WORKERS[@]}; do\n  scp ca.pem ${instance}-key.pem ${instance}.pem root@${instance}:~/\ndone\n分发Master节点需要的证书和私钥\n\n根证书和密钥(ca*.pem)\nkube-apiserver证书和密钥(kubenetes*.pem)\nservice-account证书和密钥(service-account*.pem)\nproxy-client证书和密钥(proxy-client*.pem)\n\nMASTER_IPS=(cluster1 cluster2)\nfor instance in ${MASTER_IPS[@]}; do\n  scp ca.pem ca-key.pem kubernetes-key.pem kubernetes.pem \\\n    service-account-key.pem service-account.pem proxy-client.pem proxy-client-key.pem root@${instance}:~/\ndone\n\n\n\nkubernetes各组件的认证配置\nkubernetes的认证配置文件，称为kubeconfigs，用于让kubernetes的客户端定位 kube-apiserver并通过apiserver的安全认证。\n\ncontroller-manager\nkubelet\nkube-proxy\nscheduler\nadmin user\n\n\n为kubelet生成kubeconfigs(每个Worker节点)\n\nWORKERS=(\"cluster2\" \"cluster3\")\nfor instance in ${WORKERS[@]}; do\n  kubectl config set-cluster kubernetes \\\n    --certificate-authority=ca.pem \\\n    --embed-certs=true \\\n    --server=https://127.0.0.1:6443 \\\n    --kubeconfig=${instance}.kubeconfig\n\n  kubectl config set-credentials system:node:${instance} \\\n    --client-certificate=${instance}.pem \\\n    --client-key=${instance}-key.pem \\\n    --embed-certs=true \\\n    --kubeconfig=${instance}.kubeconfig\n\n  kubectl config set-context default \\\n    --cluster=kubernetes \\\n    --user=system:node:${instance} \\\n    --kubeconfig=${instance}.kubeconfig\n\n  kubectl config use-context default --kubeconfig=${instance}.kubeconfig\ndone\n\n为kube-proxy生成kubeconfigs\n\nkubectl config set-cluster kubernetes \\\n    --certificate-authority=ca.pem \\\n    --embed-certs=true \\\n    --server=https://127.0.0.1:6443 \\\n    --kubeconfig=kube-proxy.kubeconfig\n\nkubectl config set-credentials system:kube-proxy \\\n  --client-certificate=kube-proxy.pem \\\n  --client-key=kube-proxy-key.pem \\\n  --embed-certs=true \\\n  --kubeconfig=kube-proxy.kubeconfig\n\nkubectl config set-context default \\\n  --cluster=kubernetes \\\n  --user=system:kube-proxy \\\n  --kubeconfig=kube-proxy.kubeconfig\n\nkubectl config use-context default --kubeconfig=kube-proxy.kubeconfig\n\n为kube-controller-manager生成kubeconfigs\n\nkubectl config set-cluster kubernetes \\\n  --certificate-authority=ca.pem \\\n  --embed-certs=true \\\n  --server=https://127.0.0.1:6443 \\\n  --kubeconfig=kube-controller-manager.kubeconfig\n\nkubectl config set-credentials system:kube-controller-manager \\\n  --client-certificate=kube-controller-manager.pem \\\n  --client-key=kube-controller-manager-key.pem \\\n  --embed-certs=true \\\n  --kubeconfig=kube-controller-manager.kubeconfig\n\nkubectl config set-context default \\\n  --cluster=kubernetes \\\n  --user=system:kube-controller-manager \\\n  --kubeconfig=kube-controller-manager.kubeconfig\n\nkubectl config use-context default --kubeconfig=kube-controller-manager.kubeconfig\n\n为kube-scheduler生成kubeconfigs\n\nkubectl config set-cluster kubernetes \\\n  --certificate-authority=ca.pem \\\n  --embed-certs=true \\\n  --server=https://127.0.0.1:6443 \\\n  --kubeconfig=kube-scheduler.kubeconfig\n\nkubectl config set-credentials system:kube-scheduler \\\n  --client-certificate=kube-scheduler.pem \\\n  --client-key=kube-scheduler-key.pem \\\n  --embed-certs=true \\\n  --kubeconfig=kube-scheduler.kubeconfig\n\nkubectl config set-context default \\\n  --cluster=kubernetes \\\n  --user=system:kube-scheduler \\\n  --kubeconfig=kube-scheduler.kubeconfig\n\nkubectl config use-context default --kubeconfig=kube-scheduler.kubeconfig\n\n为admin用户生成kubeconfigs\n\nkubectl config set-cluster kubernetes \\\n  --certificate-authority=ca.pem \\\n  --embed-certs=true \\\n  --server=https://127.0.0.1:6443 \\\n  --kubeconfig=admin.kubeconfig\n\nkubectl config set-credentials admin \\\n  --client-certificate=admin.pem \\\n  --client-key=admin-key.pem \\\n  --embed-certs=true \\\n  --kubeconfig=admin.kubeconfig\n\nkubectl config set-context default \\\n  --cluster=kubernetes \\\n  --user=admin \\\n  --kubeconfig=admin.kubeconfig\n\nkubectl config use-context default --kubeconfig=admin.kubeconfig\n\n分发kubeconfigs配置文件\n\n\nkubelet和kube-proxy的kubeconfigs分发到Worker节点\n\nWORKERS=(\"cluster2\" \"cluster3\")\nfor instance in ${WORKERS[@]}; do\n  scp ${instance}.kubeconfig kube-proxy.kubeconfig ${instance}:~/\ndone\n\nkube-controller-manager和kube-scheduler的kubeconfigs分发到Master节点\n\nMASTERS=(\"cluster1\" \"cluster2\")\nfor instance in ${MASTERS[@]}; do\n  scp admin.kubeconfig kube-controller-manager.kubeconfig kube-scheduler.kubeconfig ${instance}:~/\ndone\n\n\n部署ETCD集群\n\n配置etcd证书文件\n\nmkdir -p /etc/etcd /var/lib/etcd\nchmod 700 /var/lib/etcd\ncp ca.pem kubernetes-key.pem kubernetes.pem /etc/etcd/\n\n配置etcd.service文件\n\n\nECCD_IP: 为当前ectd存储服务器的IP\n\nETCD_NAME=$(hostname -s)\nETCD_IP=192.168.200.11\nETCD_NAMES=(cluster1 cluster2 cluster3)\nETCD_IPS=(192.168.200.11 192.168.200.22 192.168.200.33)\ncat &lt;&lt;EOF &gt; /etc/systemd/system/etcd.service\n[Unit]\nDescription=etcd\nDocumentation=https://github.com/coreos\n\n[Service]\nType=notify\nExecStart=/usr/local/bin/etcd \\\\\n  --name ${ETCD_NAME} \\\\\n  --cert-file=/etc/etcd/kubernetes.pem \\\\\n  --key-file=/etc/etcd/kubernetes-key.pem \\\\\n  --peer-cert-file=/etc/etcd/kubernetes.pem \\\\\n  --peer-key-file=/etc/etcd/kubernetes-key.pem \\\\\n  --trusted-ca-file=/etc/etcd/ca.pem \\\\\n  --peer-trusted-ca-file=/etc/etcd/ca.pem \\\\\n  --peer-client-cert-auth \\\\\n  --client-cert-auth \\\\\n  --initial-advertise-peer-urls https://${ETCD_IP}:2380 \\\\\n  --listen-peer-urls https://${ETCD_IP}:2380 \\\\\n  --listen-client-urls https://${ETCD_IP}:2379,https://127.0.0.1:2379 \\\\\n  --advertise-client-urls https://${ETCD_IP}:2379 \\\\\n  --initial-cluster-token etcd-cluster-0 \\\\\n  --initial-cluster ${ETCD_NAMES[0]}=https://${ETCD_IPS[0]}:2380,${ETCD_NAMES[1]}=https://${ETCD_IPS[1]}:2380,${ETCD_NAMES[2]}=https://${ETCD_IPS[2]}:2380 \\\\\n  --initial-cluster-state new \\\\\n  --data-dir=/var/lib/etcd\nRestart=on-failure\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n启动etcd集群\n\nsystemctl daemon-reload && systemctl enable etcd && systemctl start etcd\n\n验证etcd集群\n\nETCDCTL_API=3 etcdctl member list \\\n--endpoints=https://127.0.0.1:2379 \\\n--cacert=/etc/etcd/ca.pem \\\n--cert=/etc/etcd/kubernetes.pem \\\n--key=/etc/etcd/kubernetes-key.pem\n成功输出结果如下(不同机器不同):\n87db4208f2c1d75, started, cluster2, https://192.168.200.22:2380, https://192.168.200.22:2379, false\n95c5677668e390bf, started, cluster1, https://192.168.200.11:2380, https://192.168.200.11:2379, false\nd728cb204dcd87a3, started, cluster3, https://192.168.200.33:2380, https://192.168.200.33:2379, false\n\n\n部署kubernetes控制面板\n每个组件有多个点保证高可用。 我们在cluster1和cluster2上部署kube-apiserver,kube-contronller-manager,kube-scheduler\n\n配置API Server(每个master节点都需要配置)\n\nmkdir -p /etc/kubernetes/ssl\n\nmv ca.pem ca-key.pem kubernetes-key.pem kubernetes.pem \\\n  service-account-key.pem service-account.pem \\\n  proxy-client.pem proxy-client-key.pem \\\n  /etc/kubernetes/ssl\n\nIP=192.168.200.11\nAPISERVER_COUNT=2\nETCD_ENDPOINTS=(192.168.200.11 192.168.200.22 192.168.200.33)\n\ncat &lt;&lt;EOF &gt; /etc/systemd/system/kube-apiserver.service\n[Unit]\nDescription=Kubernetes API Server\nDocumentation=https://github.com/kubernetes/kubernetes\n\n[Service]\nExecStart=/usr/local/bin/kube-apiserver \\\\\n  --advertise-address=${IP} \\\\\n  --allow-privileged=true \\\\\n  --apiserver-count=${APISERVER_COUNT} \\\\\n  --audit-log-maxage=30 \\\\\n  --audit-log-maxbackup=3 \\\\\n  --audit-log-maxsize=100 \\\\\n  --audit-log-path=/var/log/audit.log \\\\\n  --authorization-mode=Node,RBAC \\\\\n  --bind-address=0.0.0.0 \\\\\n  --client-ca-file=/etc/kubernetes/ssl/ca.pem \\\\\n  --enable-admission-plugins=NamespaceLifecycle,NodeRestriction,LimitRanger,ServiceAccount,DefaultStorageClass,ResourceQuota \\\\\n  --etcd-cafile=/etc/kubernetes/ssl/ca.pem \\\\\n  --etcd-certfile=/etc/kubernetes/ssl/kubernetes.pem \\\\\n  --etcd-keyfile=/etc/kubernetes/ssl/kubernetes-key.pem \\\\\n  --etcd-servers=https://${ETCD_ENDPOINTS[0]}:2379,https://${ETCD_ENDPOINTS[1]}:2379,https://${ETCD_ENDPOINTS[2]}:2379 \\\\\n  --event-ttl=1h \\\\\n  --kubelet-certificate-authority=/etc/kubernetes/ssl/ca.pem \\\\\n  --kubelet-client-certificate=/etc/kubernetes/ssl/kubernetes.pem \\\\\n  --kubelet-client-key=/etc/kubernetes/ssl/kubernetes-key.pem \\\\\n  --service-account-issuer=api \\\\\n  --service-account-key-file=/etc/kubernetes/ssl/service-account.pem \\\\\n  --service-account-signing-key-file=/etc/kubernetes/ssl/service-account-key.pem \\\\\n  --api-audiences=api,vault,factors \\\\\n  --service-cluster-ip-range=10.233.0.0/16 \\\\\n  --service-node-port-range=30000-32767 \\\\\n  --proxy-client-cert-file=/etc/kubernetes/ssl/proxy-client.pem \\\\\n  --proxy-client-key-file=/etc/kubernetes/ssl/proxy-client-key.pem \\\\\n  --runtime-config=api/all=true \\\\\n  --requestheader-client-ca-file=/etc/kubernetes/ssl/ca.pem \\\\\n  --requestheader-allowed-names=aggregator \\\\\n  --requestheader-extra-headers-prefix=X-Remote-Extra- \\\\\n  --requestheader-group-headers=X-Remote-Group \\\\\n  --requestheader-username-headers=X-Remote-User \\\\\n  --tls-cert-file=/etc/kubernetes/ssl/kubernetes.pem \\\\\n  --tls-private-key-file=/etc/kubernetes/ssl/kubernetes-key.pem \\\\\n  --v=1\nRestart=on-failure\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n配置kube-controller-manager\n\nmv kube-controller-manager.kubeconfig /etc/kubernetes/\n\ncat &lt;&lt;EOF &gt; /etc/systemd/system/kube-controller-manager.service\n[Unit]\nDescription=Kubernetes Controller Manager\nDocumentation=https://github.com/kubernetes/kubernetes\n\n[Service]\nExecStart=/usr/local/bin/kube-controller-manager \\\\\n  --bind-address=0.0.0.0 \\\\\n  --cluster-cidr=10.200.0.0/16 \\\\\n  --cluster-name=kubernetes \\\\\n  --cluster-signing-cert-file=/etc/kubernetes/ssl/ca.pem \\\\\n  --cluster-signing-key-file=/etc/kubernetes/ssl/ca-key.pem \\\\\n  --cluster-signing-duration=876000h0m0s \\\\\n  --kubeconfig=/etc/kubernetes/kube-controller-manager.kubeconfig \\\\\n  --leader-elect=true \\\\\n  --root-ca-file=/etc/kubernetes/ssl/ca.pem \\\\\n  --service-account-private-key-file=/etc/kubernetes/ssl/service-account-key.pem \\\\\n  --service-cluster-ip-range=10.233.0.0/16 \\\\\n  --use-service-account-credentials=true \\\\\n  --v=1\nRestart=on-failure\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n配置kube-scheduler\n\nmv kube-scheduler.kubeconfig /etc/kubernetes\n\ncat &lt;&lt;EOF &gt; /etc/systemd/system/kube-scheduler.service\n[Unit]\nDescription=Kubernetes Scheduler\nDocumentation=https://github.com/kubernetes/kubernetes\n\n[Service]\nExecStart=/usr/local/bin/kube-scheduler \\\\\n  --authentication-kubeconfig=/etc/kubernetes/kube-scheduler.kubeconfig \\\\\n  --authorization-kubeconfig=/etc/kubernetes/kube-scheduler.kubeconfig \\\\\n  --kubeconfig=/etc/kubernetes/kube-scheduler.kubeconfig \\\\\n  --leader-elect=true \\\\\n  --bind-address=0.0.0.0 \\\\\n  --port=0 \\\\\n  --v=1\nRestart=on-failure\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n启动服务\n\nsystemctl daemon-reload\nsystemctl enable kube-apiserver\nsystemctl enable kube-controller-manager\nsystemctl enable kube-scheduler\nsystemctl start kube-apiserver\nsystemctl start kube-controller-manager\nsystemctl start kube-scheduler\n\n服务验证\n\nnetstat -ntlp\n正常输出如下:\ntcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      18829/sshd\ntcp        0      0 127.0.0.1:25            0.0.0.0:*               LISTEN      853/master\ntcp        0      0 192.168.200.11:2379     0.0.0.0:*               LISTEN      30516/etcd\ntcp        0      0 127.0.0.1:2379          0.0.0.0:*               LISTEN      30516/etcd\ntcp        0      0 192.168.200.11:2380     0.0.0.0:*               LISTEN      30516/etcd\ntcp6       0      0 ::1:25                  :::*                    LISTEN      853/master\ntcp6       0      0 :::6443                 :::*                    LISTEN      30651/kube-apiserve\ntcp6       0      0 :::10257                :::*                    LISTEN      30666/kube-controll\ntcp6       0      0 :::10259                :::*                    LISTEN      30679/kube-schedule\n\n配置kubectl kubectl用来管理kubernetes集群的客户端工具。\n\nmkdir ~/.kube/\nmv ~/admin.kubeconfig ~/.kube/config\nkubectl get nodes\n授权apiserver调用kubelet API,在执行kubectl exec/run/logs时apiserver会转发到kubelet\nkubectl create clusterrolebinding kube-apiserver:kubelet-apis --clusterrole=system:kubelet-api-admin --user kubernetes\n\n\nDeploy kubernetes Worker Node\n每个节点上都会部署:\n\nkubelet\nkube-proxy\ncontainer runtime\ncni\nnginx-proxy\n\n\nContainer Runtine(containerd)\n\nVERSION=1.4.3\nwget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\ntar -xvf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz\ncp etc/crictl.yaml /etc/\ncp etc/systemd/system/containerd.service /etc/systemd/system/\ncp -r usr /\n\ncontainerd配置文件\n\nmkdir -p /etc/containerd\ncontainerd config default &gt; /etc/containerd/config.toml\n# Options\nvi /etc/containerd/config.toml\n\n启动containerd\n\nsystemctl enable containerd\nsystemctl start containerd\nsystemctl status containerd\n\n配置kubelet\n\n\n准备配置文件\n\nmkdir -p /etc/kubernetes/ssl/\nmv ${HOSTNAME}-key.pem ${HOSTNAME}.pem ca.pem ca-key.pem /etc/kubernetes/ssl/\nmv ${HOSTNAME}.kubeconfig /etc/kubernetes/kubeconfig\nIP=192.168.200.22\n\ncat &lt;&lt;EOF &gt; /etc/kubernetes/kubelet-config.yaml\nkind: KubeletConfiguration\napiVersion: kubelet.config.k8s.io/v1beta1\nauthentication:\n  anonymous:\n    enabled: false\n  webhook:\n    enabled: true\n  x509:\n    clientCAFile: \"/etc/kubernetes/ssl/ca.pem\"\nauthorization:\n  mode: Webhook\nclusterDomain: \"cluster.local\"\nclusterDNS:\n  - \"169.254.25.10\"\npodCIDR: \"10.200.0.0/16\"\naddress: ${IP}\nreadOnlyPort: 0\nstaticPodPath: /etc/kubernetes/manifests\nhealthzPort: 10248\nhealthzBindAddress: 127.0.0.1\nkubeletCgroups: /systemd/system.slice\nresolvConf: \"/etc/resolv.conf\"\nruntimeRequestTimeout: \"15m\"\nkubeReserved:\n  cpu: 200m\n  memory: 512M\ntlsCertFile: \"/etc/kubernetes/ssl/${HOSTNAME}.pem\"\ntlsPrivateKeyFile: \"/etc/kubernetes/ssl/${HOSTNAME}-key.pem\"\nEOF\n\n配置服务\n\ncat &lt;&lt;EOF &gt; /etc/systemd/system/kubelet.service\n[Unit]\nDescription=Kubernetes Kubelet\nDocumentation=https://github.com/kubernetes/kubernetes\nAfter=containerd.service\nRequires=containerd.service\n\n[Service]\nExecStart=/usr/local/bin/kubelet \\\\\n  --config=/etc/kubernetes/kubelet-config.yaml \\\\\n  --container-runtime=remote \\\\\n  --container-runtime-endpoint=unix:///var/run/containerd/containerd.sock \\\\\n  --image-pull-progress-deadline=2m \\\\\n  --kubeconfig=/etc/kubernetes/kubeconfig \\\\\n  --network-plugin=cni \\\\\n  --node-ip=${IP} \\\\\n  --register-node=true \\\\\n  --v=2\nRestart=on-failure\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n配置nginx-proxy nginx-proxy是有一个用于Worker节点访问apiserver的一个代理， 是apiserver一个优雅的高可用方案。 它使用kubelet的staticpod方式启动，让每个节点都可以均衡的访问每个apiserver服务 优雅的替代了通过虚拟ip访问apiserver的方式。\n\n只需要在没有``apiserver的节点部署\n注意stream中有几个节点写几个\nmkdir -p /etc/nginx\nMASTER_IPS=(10.155.19.223 10.155.19.64)\n\ncat &lt;&lt;EOF &gt; /etc/nginx/nginx.conf\nerror_log stderr notice;\n\nworker_processes 2;\nworker_rlimit_nofile 130048;\nworker_shutdown_timeout 10s;\n\nevents {\n  multi_accept on;\n  use epoll;\n  worker_connections 16384;\n}\n\nstream {\n  upstream kube_apiserver {\n    least_conn;\n    server ${MASTER_IPS[0]}:6443;\n    server ${MASTER_IPS[1]}:6443;\n    ...\n    server ${MASTER_IPS[N]}:6443;\n  }\n\n  server {\n    listen        127.0.0.1:6443;\n    proxy_pass    kube_apiserver;\n    proxy_timeout 10m;\n    proxy_connect_timeout 1s;\n  }\n}\n\nhttp {\n  aio threads;\n  aio_write on;\n  tcp_nopush on;\n  tcp_nodelay on;\n\n  keepalive_timeout 5m;\n  keepalive_requests 100;\n  reset_timedout_connection on;\n  server_tokens off;\n  autoindex off;\n\n  server {\n    listen 8081;\n    location /healthz {\n      access_log off;\n      return 200;\n    }\n    location /stub_status {\n      stub_status on;\n      access_log off;\n    }\n  }\n}\nEOF\n\nNginx manifest\n\ncat &lt;&lt;EOF &gt; /etc/kubernetes/manifests/nginx-proxy.yaml\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx-proxy\n  namespace: kube-system\n  labels:\n    addonmanager.kubernetes.io/mode: Reconcile\n    k8s-app: kube-nginx\nspec:\n  hostNetwork: true\n  dnsPolicy: ClusterFirstWithHostNet\n  nodeSelector:\n    kubernetes.io/os: linux\n  priorityClassName: system-node-critical\n  containers:\n  - name: nginx-proxy\n    image: docker.io/library/nginx:1.19\n    imagePullPolicy: IfNotPresent\n    resources:\n      requests:\n        cpu: 25m\n        memory: 32M\n    securityContext:\n      privileged: true\n    livenessProbe:\n      httpGet:\n        path: /healthz\n        port: 8081\n    readinessProbe:\n      httpGet:\n        path: /healthz\n        port: 8081\n    volumeMounts:\n    - mountPath: /etc/nginx\n      name: etc-nginx\n      readOnly: true\n  volumes:\n  - name: etc-nginx\n    hostPath:\n      path: /etc/nginx\nEOF\n\n配置kube-proxy\n\n\n配置文件\n\nmv kube-proxy.kubeconfig /etc/kubernetes/\ncat &lt;&lt;EOF &gt; /etc/kubernetes/kube-proxy-config.yaml\napiVersion: kubeproxy.config.k8s.io/v1alpha1\nkind: KubeProxyConfiguration\nbindAddress: 0.0.0.0\nclientConnection:\n  kubeconfig: \"/etc/kubernetes/kube-proxy.kubeconfig\"\nclusterCIDR: \"10.200.0.0/16\"\nmode: ipvs\nEOF\n\nkube-proxy服务文件\n\ncat &lt;&lt;EOF &gt; /etc/systemd/system/kube-proxy.service\n[Unit]\nDescription=Kubernetes Kube Proxy\nDocumentation=https://github.com/kubernetes/kubernetes\n\n[Service]\nExecStart=/usr/local/bin/kube-proxy \\\\\n  --config=/etc/kubernetes/kube-proxy-config.yaml\nRestart=on-failure\nRestartSec=5\n\n[Install]\nWantedBy=multi-user.target\nEOF\n\n服务启动\n\nsystemctl daemon-reload\nsystemctl enable kubelet kube-proxy\nsystemctl start kubelet kube-proxy\njournalctl -f -u kubelet\njournalctl -f -u kube-proxy\n\n手动下载镜像pause(服务器无法访问外网) 在每个节点下载(master节点不下载可能不能成功)\n\ncrictl pull registry.cn-hangzhou.aliyuncs.com/kubernetes-kubespray/pause:3.2\nctr -n k8s.io i tag  registry.cn-hangzhou.aliyuncs.com/kubernetes-kubespray/pause:3.2 k8s.gcr.io/pause:3.2\n\n主动拉取/etc/kubernetes/manifests/nginx-proxy.yaml文件中的nginx镜像 具体版本，查看文件中的版本信息\n\ncrictl pull docker.io/library/nginx:1.19\n\n\n网络插件Calico\n\nYAML文件需要从官网下载\n\n\n链接: https://docs.projectcalico.org/getting-started/kubernetes/self-managed-onprem/onpremises\n有两种配置，50节点以内或者以上\n具体版本看官网信息，一下链接可能版本会不同\n\ncurl https://raw.githubusercontent.com/projectcalico/calico/v3.24.5/manifests/calico.yaml -O\n\n修改IP自动发现方式\n\n\nautodetect 可能会有问题\n当kubelet的启动参数中存在–node-ip的时候，以host-network模式启动的pod的status.hostIP字段就会自动填入kubelet中指定的ip地址\n\n修改前:\n- name: IP\n  value: \"autodetect\"\n修改后:\n- name: IP\n  valueFrom:\n    fieldRef:\n      fieldPath: status.hostIP\n\n修改CIDR\n\n修改前:\n# - name: CALICO_IPV4POOL_CIDR\n#   value: \"192.168.0.0/16\"\n修改后:\n- name: CALICO_IPV4POOL_CIDR\n  value: \"10.200.0.0/16\"\n\n启动calico\n\nkubectl apply -f calico.yaml\n\n\nDNS插件CoreDNS\n\nDeploy CoreDNS\n\n\n设置coredns的cluster-ip\n下载coredns.yaml\n替换cluster-ip\n创建coredns\n\nCOREDNS_CLUSTER_IP=10.233.0.10\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: coredns\n  namespace: kube-system\n  labels:\n      addonmanager.kubernetes.io/mode: EnsureExists\ndata:\n  Corefile: |\n    .:53 {\n        errors\n        health {\n            lameduck 5s\n        }\n        ready\n        kubernetes cluster.local in-addr.arpa ip6.arpa {\n          pods insecure\n          fallthrough in-addr.arpa ip6.arpa\n        }\n        prometheus :9153\n        forward . /etc/resolv.conf {\n          prefer_udp\n        }\n        cache 30\n        loop\n        reload\n        loadbalance\n    }\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: coredns\n  namespace: kube-system\n  labels:\n    addonmanager.kubernetes.io/mode: Reconcile\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRole\nmetadata:\n  labels:\n    kubernetes.io/bootstrapping: rbac-defaults\n    addonmanager.kubernetes.io/mode: Reconcile\n  name: system:coredns\nrules:\n  - apiGroups:\n      - \"\"\n    resources:\n      - endpoints\n      - services\n      - pods\n      - namespaces\n    verbs:\n      - list\n      - watch\n  - apiGroups:\n      - \"\"\n    resources:\n      - nodes\n    verbs:\n      - get\n---\napiVersion: rbac.authorization.k8s.io/v1\nkind: ClusterRoleBinding\nmetadata:\n  annotations:\n    rbac.authorization.kubernetes.io/autoupdate: \"true\"\n  labels:\n    kubernetes.io/bootstrapping: rbac-defaults\n    addonmanager.kubernetes.io/mode: EnsureExists\n  name: system:coredns\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: system:coredns\nsubjects:\n  - kind: ServiceAccount\n    name: coredns\n    namespace: kube-system\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: coredns\n  namespace: kube-system\n  labels:\n    k8s-app: kube-dns\n    kubernetes.io/name: \"coredns\"\n    addonmanager.kubernetes.io/mode: Reconcile\n  annotations:\n    prometheus.io/port: \"9153\"\n    prometheus.io/scrape: \"true\"\nspec:\n  selector:\n    k8s-app: kube-dns\n  clusterIP: ${COREDNS_CLUSTER_IP}\n  ports:\n    - name: dns\n      port: 53\n      protocol: UDP\n    - name: dns-tcp\n      port: 53\n      protocol: TCP\n    - name: metrics\n      port: 9153\n      protocol: TCP\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: \"coredns\"\n  namespace: kube-system\n  labels:\n    k8s-app: \"kube-dns\"\n    addonmanager.kubernetes.io/mode: Reconcile\n    kubernetes.io/name: \"coredns\"\nspec:\n  replicas: 2\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxUnavailable: 0\n      maxSurge: 10%\n  selector:\n    matchLabels:\n      k8s-app: kube-dns\n  template:\n    metadata:\n      labels:\n        k8s-app: kube-dns\n      annotations:\n        seccomp.security.alpha.kubernetes.io/pod: 'runtime/default'\n    spec:\n      priorityClassName: system-cluster-critical\n      nodeSelector:\n        kubernetes.io/os: linux\n      serviceAccountName: coredns\n      tolerations:\n        - key: node-role.kubernetes.io/master\n          effect: NoSchedule\n      affinity:\n        podAntiAffinity:\n          requiredDuringSchedulingIgnoredDuringExecution:\n          - topologyKey: \"kubernetes.io/hostname\"\n            labelSelector:\n              matchLabels:\n                k8s-app: kube-dns\n        nodeAffinity:\n          preferredDuringSchedulingIgnoredDuringExecution:\n          - weight: 100\n            preference:\n              matchExpressions:\n              - key: node-role.kubernetes.io/master\n                operator: In\n                values:\n                - \"\"\n      containers:\n      - name: coredns\n        image: \"docker.io/coredns/coredns:1.6.7\"\n        imagePullPolicy: IfNotPresent\n        resources:\n          # TODO: Set memory limits when we've profiled the container for large\n          # clusters, then set request = limit to keep this container in\n          # guaranteed class. Currently, this container falls into the\n          # \"burstable\" category so the kubelet doesn't backoff from restarting it.\n          limits:\n            memory: 170Mi\n          requests:\n            cpu: 100m\n            memory: 70Mi\n        args: [ \"-conf\", \"/etc/coredns/Corefile\" ]\n        volumeMounts:\n        - name: config-volume\n          mountPath: /etc/coredns\n        ports:\n        - containerPort: 53\n          name: dns\n          protocol: UDP\n        - containerPort: 53\n          name: dns-tcp\n          protocol: TCP\n        - containerPort: 9153\n          name: metrics\n          protocol: TCP\n        securityContext:\n          allowPrivilegeEscalation: false\n          capabilities:\n            add:\n            - NET_BIND_SERVICE\n            drop:\n            - all\n          readOnlyRootFilesystem: true\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 8080\n            scheme: HTTP\n          timeoutSeconds: 5\n          successThreshold: 1\n          failureThreshold: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 8181\n            scheme: HTTP\n          timeoutSeconds: 5\n          successThreshold: 1\n          failureThreshold: 10\n      dnsPolicy: Default\n      volumes:\n        - name: config-volume\n          configMap:\n            name: coredns\n            items:\n            - key: Corefile\n              path: Corefile\n  ```\n\n```bash\nsed -i \"s/\\${COREDNS_CLUSTER_IP}/${COREDNS_CLUSTER_IP}/g\" coredns.yaml\nkubectl apply -f coredns.yaml\n\nDeploy NodeLocal DNSCache\n\n\n设置coredns的cluster-ip\n下载nodelocaldns.yaml\n替换`cluster-ip\n创建nodelocaldns\n\nCOREDNS_CLUSTER_IP=10.233.0.10\n---\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: nodelocaldns\n  namespace: kube-system\n  labels:\n    addonmanager.kubernetes.io/mode: EnsureExists\n\ndata:\n  Corefile: |\n    cluster.local:53 {\n        errors\n        cache {\n            success 9984 30\n            denial 9984 5\n        }\n        reload\n        loop\n        bind 169.254.25.10\n        forward . ${COREDNS_CLUSTER_IP} {\n            force_tcp\n        }\n        prometheus :9253\n        health 169.254.25.10:9254\n    }\n    in-addr.arpa:53 {\n        errors\n        cache 30\n        reload\n        loop\n        bind 169.254.25.10\n        forward . ${COREDNS_CLUSTER_IP} {\n            force_tcp\n        }\n        prometheus :9253\n    }\n    ip6.arpa:53 {\n        errors\n        cache 30\n        reload\n        loop\n        bind 169.254.25.10\n        forward . ${COREDNS_CLUSTER_IP} {\n            force_tcp\n        }\n        prometheus :9253\n    }\n    .:53 {\n        errors\n        cache 30\n        reload\n        loop\n        bind 169.254.25.10\n        forward . /etc/resolv.conf\n        prometheus :9253\n    }\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: nodelocaldns\n  namespace: kube-system\n  labels:\n    k8s-app: kube-dns\n    addonmanager.kubernetes.io/mode: Reconcile\nspec:\n  selector:\n    matchLabels:\n      k8s-app: nodelocaldns\n  template:\n    metadata:\n      labels:\n        k8s-app: nodelocaldns\n      annotations:\n        prometheus.io/scrape: 'true'\n        prometheus.io/port: '9253'\n    spec:\n      priorityClassName: system-cluster-critical\n      serviceAccountName: nodelocaldns\n      hostNetwork: true\n      dnsPolicy: Default  # Don't use cluster DNS.\n      tolerations:\n      - effect: NoSchedule\n        operator: \"Exists\"\n      - effect: NoExecute\n        operator: \"Exists\"\n      containers:\n      - name: node-cache\n        image: \"registry.cn-hangzhou.aliyuncs.com/kubernetes-kubespray/dns_k8s-dns-node-cache:1.16.0\"\n        resources:\n          limits:\n            memory: 170Mi\n          requests:\n            cpu: 100m\n            memory: 70Mi\n        args: [ \"-localip\", \"169.254.25.10\", \"-conf\", \"/etc/coredns/Corefile\", \"-upstreamsvc\", \"coredns\" ]\n        securityContext:\n          privileged: true\n        ports:\n        - containerPort: 53\n          name: dns\n          protocol: UDP\n        - containerPort: 53\n          name: dns-tcp\n          protocol: TCP\n        - containerPort: 9253\n          name: metrics\n          protocol: TCP\n        livenessProbe:\n          httpGet:\n            host: 169.254.25.10\n            path: /health\n            port: 9254\n            scheme: HTTP\n          timeoutSeconds: 5\n          successThreshold: 1\n          failureThreshold: 10\n        readinessProbe:\n          httpGet:\n            host: 169.254.25.10\n            path: /health\n            port: 9254\n            scheme: HTTP\n          timeoutSeconds: 5\n          successThreshold: 1\n          failureThreshold: 10\n        volumeMounts:\n        - name: config-volume\n          mountPath: /etc/coredns\n        - name: xtables-lock\n          mountPath: /run/xtables.lock\n      volumes:\n        - name: config-volume\n          configMap:\n            name: nodelocaldns\n            items:\n            - key: Corefile\n              path: Corefile\n        - name: xtables-lock\n          hostPath:\n            path: /run/xtables.lock\n            type: FileOrCreate\n      # Minimize downtime during a rolling upgrade or deletion; tell Kubernetes to do a \"force\n      # deletion\": https://kubernetes.io/docs/concepts/workloads/pods/pod/#termination-of-pods.\n      terminationGracePeriodSeconds: 0\n  updateStrategy:\n    rollingUpdate:\n      maxUnavailable: 20%\n    type: RollingUpdate\n---\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: nodelocaldns\n  namespace: kube-system\n  labels:\n    addonmanager.kubernetes.io/mode: Reconcile\nsed -i \"s/\\${COREDNS_CLUSTER_IP}/${COREDNS_CLUSTER_IP}/g\" nodelocaldns.yaml\nkubectl apply -f nodelocaldns.yaml\n\n\n集群冒烟测试\n\n创建nginx ds\n\ncat &gt; nginx-ds.yml &lt;&lt;EOF\napiVersion: v1\nkind: Service\nmetadata:\n  name: nginx-ds\n  labels:\n    app: nginx-ds\nspec:\n  type: NodePort\n  selector:\n    app: nginx-ds\n  ports:\n  - name: http\n    port: 80\n    targetPort: 80\n---\napiVersion: apps/v1\nkind: DaemonSet\nmetadata:\n  name: nginx-ds\nspec:\n  selector:\n    matchLabels:\n      app: nginx-ds\n  template:\n    metadata:\n      labels:\n        app: nginx-ds\n    spec:\n      containers:\n      - name: my-nginx\n        image: nginx:1.19\n        ports:\n        - containerPort: 80\nEOF\n\nkubectl apply -f nginx-ds.yml\n\n检查各种IP连通性\n\n\n查看各Node上的Pod IP连通性\n\nkubectl get pods -o wide\n如下图 \n\n在每个Worker节点上ping pod ip\n\nping &lt;pod-ip&gt; #上图中查出来的\n\n查看service可达性\n\nkubectl get svc\n\n# 在每个`Worker`节点上访问服务\ncurl &lt;service-ip&gt;:&lt;port&gt; # 80\n\n在每个节点上检查`node-port`可用性\ncurl &lt;node-ip&gt;:&lt;port&gt; # node-ip: 192.168.200.22, port: 上图中80后面的端口号\n如下图: \n\n检查dns可用性\n\ncat &gt; pod-nginx.yaml &lt;&lt;EOF\napiVersion: v1\nkind: Pod\nmetadata:\n  name: nginx\nspec:\n  containers:\n  - name: nginx\n    image: docker.io/library/nginx:1.19\n    ports:\n    - containerPort: 80\nEOF\n\n# 创建pod\n$ kubectl apply -f pod-nginx.yaml\n\n# 进入pod，查看dns(根据pod名)\n$ kubectl exec nginx -it -- /bin/bash\n\n# 查看dns配置(IP)\nroot@nginx:/# cat /etc/resolv.conf\n\n# 查看名字是否可以正确解析\nroot@nginx:/# curl nginx-ds"
  },
  {
    "objectID": "posts/poetry_githubactions/index.html",
    "href": "posts/poetry_githubactions/index.html",
    "title": "Poetry & Github Action",
    "section": "",
    "text": "使用Poetry做Python的项目管理工具，集成到Github Actions，包含以下内容: - Check out 代码仓库 - 启动Python环境，可以限制版本，也可以使用多个版本 - 安装Poetry - 设置虚拟环境缓存 - 安装依赖 - 代码格式化(yapf) - 代码静态类型检查(pytype) - 代码测试，以及覆盖率测试报告\nGithub Action workflow 配置如下:\nname: CI\non: push\n\njobs:\n  ci:\n    strategy:\n      fail-fast: false\n      matrix:\n        python-version: [\"3.8.5\"]\n        poetry-version: [\"1.2.2\"]\n        os: [ubuntu-18.04]\n    runs-on: ${{ matrix.os }}\n    steps:\n      - name: Check out repository\n        uses: actions/checkout@v3\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n      - name: Install Poetry\n        uses: snok/install-poetry@v1\n        with:\n          virtualenvs-create: true\n          virtualenvs-in-project: true\n          installer-parallel: true\n      - name: Load cached venv\n        id: cached-poetry-dependencies\n        uses: actions/cache@v3\n        with:\n          path: .venv\n          key: venv-${{ runner.os }}-${{ steps.setup-python.outputs.python-version }}-${{ hashFiles('**/poetry.lock') }}\n\n      - name: Install Denpendencies\n        if: steps.cached-poetry-dependencies.outputs.cache-hit != 'true'\n        run: poetry install --no-interaction --no-root\n\n      - name: Code Format\n        run: poetry run yapf\n\n      - name: Type Check\n        run: poetry run pytype --config=pytype.cfg\n\n      - name: Testing and coverage\n        run: poetry run pytest --cov"
  },
  {
    "objectID": "posts/convert_latex_to_pptx/index.html",
    "href": "posts/convert_latex_to_pptx/index.html",
    "title": "从LaTex到PowerPoint",
    "section": "",
    "text": "xeLaTex         ImageMagick\nBeamer -----------&gt; PDF --------------&gt; PowerPoint\n\n\n\n\n\n\\documentclass{beamer} % 声明Latex文档格式为幻灯片\n\\begin{document} % 要显示的内容都必须卸载document环境中\n  % frame环境表示单张幻灯片页面\n  \\section{幻灯片章节名} % 显示在目录页面中的条目\n  \\subsection{子章节名} % 可选\n  \\begin{frame}{幻灯片主题}{幻灯片子主题}\n  \\end{frame}\n\\end{document}\n\n\n\n\nctex: 支持中文(UTF8字符)\ncolor/xcolor: 颜色\nfontspec: 字体\ngraphicx: 图形包\ntikz: 图形包\ntikz-uml: 基于tikz的UML包\n\n\n\n\n\n首页的设置放在\\begin{document}之前，不在正文部分\n\n\\title{主题}\n\\subtitle{子主题}\n\\author{作者}\n\\institute{研究所}\n\\date{日期}\n\n显示首页要放在document环境中\n\n\\begin{frame}\n  \\titlepage\n\\end{frame}\n\n\n\n\\begin{frame}\n  \\frametitle{目录}\n  \\tableofcontents\n\\end{frame}\n\n\n\n\nLists\nPictures\nDescription\nTables\nBlocks\nCode\nHyperlinks\nTheorem\n\n\n\n\n有序列表: enumerate\n无序列表: itemize\n\n\n\n\\begin{itemize}\n  \\item 条目1\n  \\item 条目2\n\\end{itemize}\n\n\n\n\n不同的序号表示方式:\n\n\n数值\n字母\n罗马数字\ni\n\n% 基于数字，默认方式\n\\begin{enumerate}\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n\\begin{enumerate}[I]\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n\\begin{enumerate}[i]\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n\\begin{enumerate}[(I)]\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n给序号添加上括号\n\n\\begin{enumerate}[(I)]\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n给需要加上强调内容\n\n\n\n\n\n导入图片，格式包括: jpg, png, pdf\n\\begin{figure}\n  % 导入图片指令, scale为图片缩放系数\n  \\includegraphics[scale=0.5]{文件路径}\n  \\caption{图片说明}\n\\end{figure}\n\n\n\n是一种Lists环境，是要用在\\item后面，内容放在方括号里面\n\\begin{description}\n  \\item[API] Application Programing Interface\n  \\item[LAN] Local Area Network\n\\end{description}\n\n\n\n\n\\hline: 表示表格中的水平线，横线\n{l | c | r}\n\n|: 用来表示表格中竖线\nl: 表示左对齐\nc: 居中\nr: 表示右对齐\n\n&: 单行中实际内容每个列之间的隔离符号\n\\\\: 表示行的换行\n\n\n\\begin{table}\n  \\begin{tabular}{l | c | r} % 表示列，如图表示三个列的竖线由 | 表示, l表示左对齐\n    \\hline % 表示画一条表格的横线\n  \\end{tabular}\n\\end{table}\n\n\n\n以块的方式显示信息。普通块与警告块。\n\\begin{block}{块名称}\n   显示内容\n\\end{block}\n\n\\begin{alertblock}{块名称} % 显示未红色\n   显示内容\n\\end{alertblock}\n\n\n\n使用listings软件包 + 设置代码风格 - 设置字体 - 设置代码字体颜色 - 设置代码风格 - 应用代码风格 + 实际代码环境\n\n设置字体，颜色以及代码风格并全局应用\n\n\\setmonofont{Monaco} % 设置等宽字体为Monaco\n\n% 设置颜色\n\\definecolor{codegreen}{rgb}{0, 0.6, 0}\n\\definecolor{codegray}{rgb}{0.5, 0.5, 0.5}\n\\definecolor{codepurple}{rgb}{0.58, 0, 0.82}\n\\definecolor{backcolor}{rgb}{0.95, 0.95, 0.92}\n\n% 代码风格设置\n\\lstdefinestyle{customstyle}{\n    backgroundcolor=\\color{backcolor},\n    commentstyle=\\color{codegreen},\n    keywordstyle=\\color{magenta},\n    numberstyle=\\color{codegray},\n    stringstyle=\\color{codepurple},\n    basicstyle=\\ttfamily\\footnotesize,\n    breakatwhitespace=false,\n    breaklines=true,\n    captionpos=b,\n    keepspaces=true,\n    numbers=left,\n    numbersep=3pt,\n    showspaces=flase,\n    showstringspaces=false,\n    showtabs=false,\n    tabsize=2,\n}\n% 应用代码风格\n\\lstset{style=customstyle}\n\n应用代码风格 在frame环境中\n\n\\lstinputlisting[\n  firstline=1, % 从文件导入代码，从文件的开始的行号\n  lastline=5, % 从文件导入代码，从文件的结束的行号\n  language=Python, % 编程语言\n  frame=single,\n  caption=First ten lines of some Python code, % 代码的说明\n  label=python\n  ]{perceptron_and.py} % 导入代码的文件\n\n\n\n\\hyperlink{链接文字描述}{链接地址}\n\n\n\n定理和推论环境会自动将其内容放在斜体字中。 beamer会自动加载amsmath软件包，所以可以直接添加数学公式。\n\\begin{theorem}[定理名称]\n$ a^2 + b^2 = c^2$\n\\end{theorem}\n\\begin{corollary} % 推论\n$ x + y = y + x  $\n\\end{corollary}\n\\begin{proof} % 论据\n$\\omega +\\phi = \\epsilon $\n\\end{proof}\n\n\n\n\n\n把Logo作为一个图片或者PDF文件\n以插入图片的方式进行插入\n对相关属性进行设置\n\n\n\n\n\n居中\n换行\n\n\n\n\\centering % 写在需要居中的环境命令上面一行\n\n\n\n\\\\\n\n\n\n\n\n使用xelatex将*.tex生成PDF文件\n使用ImageMagick的脚本将PDF转成PowerPoint\n\nxelatex demo.tex # 生成demo.pdf\n# https://github.com/ashafaei/pdf2pptx/blob/master/pdf2pptx.sh\n./pdf2pptx.sh demo.pdf # 生成 demo.pptx\n\n\n\n\n                   Pandoc\nMarkdown/Orgmode -----------&gt;  PDF/epub\npandoc参数说明 - -f: 表示from, 表示源格式 - -t: 表示to, 表示目标格式 - -o: 表示输出文件名\npandoc -f org -t pdf -o demo.pdf demo.org\npandoc -f markdown -t pdf -o demo.pdf demo.md"
  },
  {
    "objectID": "posts/convert_latex_to_pptx/index.html#从latex-beamer到powerpoint",
    "href": "posts/convert_latex_to_pptx/index.html#从latex-beamer到powerpoint",
    "title": "从LaTex到PowerPoint",
    "section": "",
    "text": "xeLaTex         ImageMagick\nBeamer -----------&gt; PDF --------------&gt; PowerPoint\n\n\n\n\n\n\\documentclass{beamer} % 声明Latex文档格式为幻灯片\n\\begin{document} % 要显示的内容都必须卸载document环境中\n  % frame环境表示单张幻灯片页面\n  \\section{幻灯片章节名} % 显示在目录页面中的条目\n  \\subsection{子章节名} % 可选\n  \\begin{frame}{幻灯片主题}{幻灯片子主题}\n  \\end{frame}\n\\end{document}\n\n\n\n\nctex: 支持中文(UTF8字符)\ncolor/xcolor: 颜色\nfontspec: 字体\ngraphicx: 图形包\ntikz: 图形包\ntikz-uml: 基于tikz的UML包\n\n\n\n\n\n首页的设置放在\\begin{document}之前，不在正文部分\n\n\\title{主题}\n\\subtitle{子主题}\n\\author{作者}\n\\institute{研究所}\n\\date{日期}\n\n显示首页要放在document环境中\n\n\\begin{frame}\n  \\titlepage\n\\end{frame}\n\n\n\n\\begin{frame}\n  \\frametitle{目录}\n  \\tableofcontents\n\\end{frame}\n\n\n\n\nLists\nPictures\nDescription\nTables\nBlocks\nCode\nHyperlinks\nTheorem\n\n\n\n\n有序列表: enumerate\n无序列表: itemize\n\n\n\n\\begin{itemize}\n  \\item 条目1\n  \\item 条目2\n\\end{itemize}\n\n\n\n\n不同的序号表示方式:\n\n\n数值\n字母\n罗马数字\ni\n\n% 基于数字，默认方式\n\\begin{enumerate}\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n\\begin{enumerate}[I]\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n\\begin{enumerate}[i]\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n\\begin{enumerate}[(I)]\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n给序号添加上括号\n\n\\begin{enumerate}[(I)]\n  \\item 条目1\n  \\item 条目2\n\\end{enumerate}\n\n给需要加上强调内容\n\n\n\n\n\n导入图片，格式包括: jpg, png, pdf\n\\begin{figure}\n  % 导入图片指令, scale为图片缩放系数\n  \\includegraphics[scale=0.5]{文件路径}\n  \\caption{图片说明}\n\\end{figure}\n\n\n\n是一种Lists环境，是要用在\\item后面，内容放在方括号里面\n\\begin{description}\n  \\item[API] Application Programing Interface\n  \\item[LAN] Local Area Network\n\\end{description}\n\n\n\n\n\\hline: 表示表格中的水平线，横线\n{l | c | r}\n\n|: 用来表示表格中竖线\nl: 表示左对齐\nc: 居中\nr: 表示右对齐\n\n&: 单行中实际内容每个列之间的隔离符号\n\\\\: 表示行的换行\n\n\n\\begin{table}\n  \\begin{tabular}{l | c | r} % 表示列，如图表示三个列的竖线由 | 表示, l表示左对齐\n    \\hline % 表示画一条表格的横线\n  \\end{tabular}\n\\end{table}\n\n\n\n以块的方式显示信息。普通块与警告块。\n\\begin{block}{块名称}\n   显示内容\n\\end{block}\n\n\\begin{alertblock}{块名称} % 显示未红色\n   显示内容\n\\end{alertblock}\n\n\n\n使用listings软件包 + 设置代码风格 - 设置字体 - 设置代码字体颜色 - 设置代码风格 - 应用代码风格 + 实际代码环境\n\n设置字体，颜色以及代码风格并全局应用\n\n\\setmonofont{Monaco} % 设置等宽字体为Monaco\n\n% 设置颜色\n\\definecolor{codegreen}{rgb}{0, 0.6, 0}\n\\definecolor{codegray}{rgb}{0.5, 0.5, 0.5}\n\\definecolor{codepurple}{rgb}{0.58, 0, 0.82}\n\\definecolor{backcolor}{rgb}{0.95, 0.95, 0.92}\n\n% 代码风格设置\n\\lstdefinestyle{customstyle}{\n    backgroundcolor=\\color{backcolor},\n    commentstyle=\\color{codegreen},\n    keywordstyle=\\color{magenta},\n    numberstyle=\\color{codegray},\n    stringstyle=\\color{codepurple},\n    basicstyle=\\ttfamily\\footnotesize,\n    breakatwhitespace=false,\n    breaklines=true,\n    captionpos=b,\n    keepspaces=true,\n    numbers=left,\n    numbersep=3pt,\n    showspaces=flase,\n    showstringspaces=false,\n    showtabs=false,\n    tabsize=2,\n}\n% 应用代码风格\n\\lstset{style=customstyle}\n\n应用代码风格 在frame环境中\n\n\\lstinputlisting[\n  firstline=1, % 从文件导入代码，从文件的开始的行号\n  lastline=5, % 从文件导入代码，从文件的结束的行号\n  language=Python, % 编程语言\n  frame=single,\n  caption=First ten lines of some Python code, % 代码的说明\n  label=python\n  ]{perceptron_and.py} % 导入代码的文件\n\n\n\n\\hyperlink{链接文字描述}{链接地址}\n\n\n\n定理和推论环境会自动将其内容放在斜体字中。 beamer会自动加载amsmath软件包，所以可以直接添加数学公式。\n\\begin{theorem}[定理名称]\n$ a^2 + b^2 = c^2$\n\\end{theorem}\n\\begin{corollary} % 推论\n$ x + y = y + x  $\n\\end{corollary}\n\\begin{proof} % 论据\n$\\omega +\\phi = \\epsilon $\n\\end{proof}\n\n\n\n\n\n把Logo作为一个图片或者PDF文件\n以插入图片的方式进行插入\n对相关属性进行设置\n\n\n\n\n\n居中\n换行\n\n\n\n\\centering % 写在需要居中的环境命令上面一行\n\n\n\n\\\\\n\n\n\n\n\n使用xelatex将*.tex生成PDF文件\n使用ImageMagick的脚本将PDF转成PowerPoint\n\nxelatex demo.tex # 生成demo.pdf\n# https://github.com/ashafaei/pdf2pptx/blob/master/pdf2pptx.sh\n./pdf2pptx.sh demo.pdf # 生成 demo.pptx"
  },
  {
    "objectID": "posts/convert_latex_to_pptx/index.html#从markdownorgmode到pdf",
    "href": "posts/convert_latex_to_pptx/index.html#从markdownorgmode到pdf",
    "title": "从LaTex到PowerPoint",
    "section": "",
    "text": "Pandoc\nMarkdown/Orgmode -----------&gt;  PDF/epub\npandoc参数说明 - -f: 表示from, 表示源格式 - -t: 表示to, 表示目标格式 - -o: 表示输出文件名\npandoc -f org -t pdf -o demo.pdf demo.org\npandoc -f markdown -t pdf -o demo.pdf demo.md"
  },
  {
    "objectID": "posts/program_basic/index.html",
    "href": "posts/program_basic/index.html",
    "title": "Programming Basic Concept",
    "section": "",
    "text": "只读数据段(RODATA/RDATE)\n堆(Heap)\n栈(Stack)\n\n\n只读数据段\n\n存放常量\n\nStack\n\n是程序运行的基础\n每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧(frame).\n自顶向下增长,出去入口帧(entry frame),就是main()对应的帧,随着main()函数一层层调用,栈会一层层扩展,调用结束,栈又会一层层回溯,把内存释放\n调用过程中,一个新的帧会分配足够的空间存储寄存器的上下文\n在函数里使用到的通用寄存器在栈保存一个副本，函数调用结束,通过副本,可以恢复出原本的寄存器的上下文\n函数的局部变量也都会在帧分配的时候被预留出来\n\nHeap\n\n当我们需要动态大小的内存时，只能用堆\n动态生命周期的内存也需要分配到堆上\n堆上分配出来的每一块内存需要显式地释放，这就使内存有更加灵活的生命周期\n\n\n\n\n\n在编译时，一切无法确定大小或者可以改变的数据，都无法安全地放在栈上，最好放在堆上\n只要可能，我们应该把变量分配到栈上，这样可以达到更好的运行速度\n栈上存放的数据是静态的，固定大小，固定生命周期，在编译期可以确定\n堆上存放的数据是动态的，不固定大小，不固定生命周期，在编译期不能确定"
  },
  {
    "objectID": "posts/program_basic/index.html#内存memory",
    "href": "posts/program_basic/index.html#内存memory",
    "title": "Programming Basic Concept",
    "section": "",
    "text": "只读数据段(RODATA/RDATE)\n堆(Heap)\n栈(Stack)\n\n\n只读数据段\n\n存放常量\n\nStack\n\n是程序运行的基础\n每当一个函数被调用时，一块连续的内存就会在栈顶被分配出来，这块内存被称为帧(frame).\n自顶向下增长,出去入口帧(entry frame),就是main()对应的帧,随着main()函数一层层调用,栈会一层层扩展,调用结束,栈又会一层层回溯,把内存释放\n调用过程中,一个新的帧会分配足够的空间存储寄存器的上下文\n在函数里使用到的通用寄存器在栈保存一个副本，函数调用结束,通过副本,可以恢复出原本的寄存器的上下文\n函数的局部变量也都会在帧分配的时候被预留出来\n\nHeap\n\n当我们需要动态大小的内存时，只能用堆\n动态生命周期的内存也需要分配到堆上\n堆上分配出来的每一块内存需要显式地释放，这就使内存有更加灵活的生命周期\n\n\n\n\n\n在编译时，一切无法确定大小或者可以改变的数据，都无法安全地放在栈上，最好放在堆上\n只要可能，我们应该把变量分配到栈上，这样可以达到更好的运行速度\n栈上存放的数据是静态的，固定大小，固定生命周期，在编译期可以确定\n堆上存放的数据是动态的，不固定大小，不固定生命周期，在编译期不能确定"
  },
  {
    "objectID": "posts/program_basic/index.html#数据",
    "href": "posts/program_basic/index.html#数据",
    "title": "Programming Basic Concept",
    "section": "数据",
    "text": "数据\n\n值\n类型\n指针\n引用\n\n\n值\n\n\n类型是对值的区分,包含了值在内存中的长度,对齐以及值可以进行操作等信息\n一个值是符合一个特定类型的数据的某个实体\n值是无法脱离具体的类型讨论的\n\n\n类型\n\n\n原生类型(primitive type): 固定大小,可以分配在栈上\n\n字符\n整数\n浮点数\n布尔值\n数组\n元组\n枚举\n指针: 指针的使用限制少，如果没有正确的类型解引用一个指针，会引发各种内存问题，造成潜在安全漏洞\n引用: 引用的解引用访问是受限的，它只能解引用到它引用数据的类型，不能用作它用\n\n组合类型(composite type)\n\n结构体: 多个类型组合在一起共同表达一个值的复杂数据结构\n标签联合: 可以存储一组不同但固定的类型的类型中的某个类型的对象，具体是由标签决定\n\n其他类型\n\n函数\n闭包"
  },
  {
    "objectID": "posts/program_basic/index.html#代码",
    "href": "posts/program_basic/index.html#代码",
    "title": "Programming Basic Concept",
    "section": "代码",
    "text": "代码\n\n函数: 对代码中重复行为的抽象\n方法: 在类中或者对象中定义的函数，只为某种类型定义的函数,和对象的指针发生关联\n闭包: 将函数或者说代码和其环境(自由变量)一起存储的一种数据结构。\n接口: 将使用方和实现方隔离开来，使两者不直接有依赖关系，大大提高了复用性和扩展性\n虚表: 存储多态接口方法的列表,辅助运行时代码执行，方便进行动态分派，是运行时多态的基础\n\n面向接口的设计师软件开发中的重要能力，当我们在运行期使用接口来引用具体类型的时候，代码就具备了运行时多态的能力。 在运行时，一旦使用了关于接口的引用，变量原本的类型被抹去，我们无法单纯从一个指针分析出这个引用具备什么样的能力。 在生成这个引用的时候，我们需要构建胖指针，除了指向数据本身，还需要指向一张涵盖这个接口所支持方法的列表。 这个列表就是我们熟知的虚表(virtual table)"
  },
  {
    "objectID": "posts/program_basic/index.html#运行方式",
    "href": "posts/program_basic/index.html#运行方式",
    "title": "Programming Basic Concept",
    "section": "运行方式",
    "text": "运行方式\n\n并发: 是一种能力, 同时与多件事情打交道的能力(交替执行多件不同的事情)\n并行: 是一种手段, 在多个CPU Core上执行同样的代码\n同步: 一个任务开始后，后续的操作会阻塞，直到这个任务结束，保证了代码的因果关系，保证程序正确性\n异步: 指一个任务开始执行后，与它没有因果关系的其它任务可以正常执行，不必等待前一个任务结束\nPromise / Future / Delay / Deferred: 是一个对象，用来描述在未来某个时刻才能获得的结果的值\nasync / await: async用来定义一个可以并发执行的任务, await则触发这个任务并执行\n\n在遭遇I/O处理时，高效CPU指令和低效I/O之间的巨大鸿沟，成为了软件的性能杀手。\n和内存访问相比，I/O操作的访问速度低了两个数量级,一旦遇到I/O操作，CPU就只能闲置来等待I/O设备运行完毕。\n因此操作系统为应用程序提供了异步I/O，让应用可以在当前I/O处理完毕之前，将CPU时间用作其它任务的处理\n很多拥有高并发处理能力的编程语言，会在用户程序中嵌入一个M:N的调度器，把M个并发任务，合理地分配在N个CPU Core上并行运行， 让程序的吞吐量达到最大。比如Golang的Goroutine\nPromise一般存在三个状态: - 初始状态, Promise还未运行 - 等待(pending)状态, Promise已运行，还未结束 - 结束状态, Promise成功解析出一个值，或者执行失败"
  },
  {
    "objectID": "posts/program_basic/index.html#编程范式",
    "href": "posts/program_basic/index.html#编程范式",
    "title": "Programming Basic Concept",
    "section": "编程范式",
    "text": "编程范式\n\n泛型编程\n\n数据结构的泛型: 把参数化数据结构理解成一个产生类型的函数，是一种高级抽象\n代码的泛型化: 当我们使用泛型结构编写代码时，相关的代码也需要额外的抽象\n\n通过参数化让数据结构像函数一样延迟绑定，提升通用性，类型的参数可以用接口约束，使类型满足一定的行为， 同时，在使用泛型结构时，我们的代码也需要更高的抽象度。"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "曳影",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nOct 12, 2023\n\n\nCLIP\n\n\n曳影 \n\n\n\n\nSep 28, 2023\n\n\nRust程序设计知识点\n\n\n曳影 \n\n\n\n\nSep 25, 2023\n\n\nRust机器学习框架-HuggingFace Candle\n\n\n曳影 \n\n\n\n\nSep 23, 2023\n\n\nRust Prelude\n\n\n曳影 \n\n\n\n\nSep 18, 2023\n\n\nWebAssembly简单介绍\n\n\n曳影 \n\n\n\n\nSep 17, 2023\n\n\nRust SDL2案例\n\n\n曳影 \n\n\n\n\nFeb 24, 2023\n\n\n从LaTex到PowerPoint\n\n\n曳影 \n\n\n\n\nDec 30, 2022\n\n\nPoetry & Github Action\n\n\n曳影 \n\n\n\n\nDec 9, 2022\n\n\nRust Toolchain常用功能介绍\n\n\n曳影 \n\n\n\n\nDec 2, 2022\n\n\nProgramming Basic Concept\n\n\n曳影 \n\n\n\n\nNov 28, 2022\n\n\nEmacs获取当前系统时间生成文件名\n\n\n曳影 \n\n\n\n\nNov 23, 2022\n\n\nDoom Emacs & Poetry & Pyright管理Python开发环境\n\n\n曳影 \n\n\n\n\nNov 19, 2022\n\n\nKubernetes the hard way\n\n\n曳影 \n\n\n\n\nNov 15, 2022\n\n\n你好, Quarto\n\n\n曳影 \n\n\n\n\n\n\nNo matching items"
  }
]